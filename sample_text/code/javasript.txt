'use strict';
const {
es5Paths,
esNextPaths,
} = require('./scripts/shared/pathsByLanguageVersion');
const restrictedGlobals = require('confusing-browser-globals');
const OFF = 0;
const WARNING = 1;
const ERROR = 2;
module.exports = {
extends: ['prettier', 'plugin:jest/recommended'],
// Stop ESLint from looking for a configuration file in parent folders
root: true,
reportUnusedDisableDirectives: true,
plugins: [
'babel',
'ft-flow',
'jest',
'no-for-of-loops',
'no-function-declare-after-return',
'react',
'react-internal',
],
parser: 'hermes-eslint',
parserOptions: {
ecmaVersion: 9,
sourceType: 'script',
},
// We're stricter than the default config, mostly. We'll override a few rules
// and then enable some React specific ones.
rules: {
'ft-flow/array-style-complex-type': [OFF, 'verbose'],
'ft-flow/array-style-simple-type': [OFF, 'verbose'], // TODO should be WARNING
'ft-flow/boolean-style': ERROR,
'ft-flow/no-dupe-keys': ERROR,
'ft-flow/no-primitive-constructor-types': ERROR,
'ft-flow/no-types-missing-file-annotation': OFF, // TODO should be ERROR
'ft-flow/no-unused-expressions': ERROR,
// 'ft-flow/no-weak-types': WARNING,
// 'ft-flow/require-valid-file-annotation': ERROR,
'no-cond-assign': OFF,
'no-constant-condition': OFF,
'no-control-regex': OFF,
'no-debugger': ERROR,
'no-dupe-args': ERROR,
'no-dupe-keys': ERROR,
'no-duplicate-case': WARNING,
'no-empty-character-class': WARNING,
'no-empty': OFF,
'no-ex-assign': WARNING,
'no-extra-boolean-cast': WARNING,
'no-func-assign': ERROR,
'no-invalid-regexp': WARNING,
'no-irregular-whitespace': WARNING,
'no-negated-in-lhs': ERROR,
'no-obj-calls': ERROR,
'no-regex-spaces': WARNING,
'no-sparse-arrays': ERROR,
'no-unreachable': ERROR,
'use-isnan': ERROR,
'valid-jsdoc': OFF,
'block-scoped-var': OFF,
complexity: OFF,
'default-case': OFF,
'guard-for-in': OFF,
'no-alert': OFF,
'no-caller': ERROR,
'no-case-declarations': OFF,
'no-div-regex': OFF,
'no-else-return': OFF,
'no-empty-pattern': WARNING,
'no-eq-null': OFF,
'no-eval': ERROR,
'no-extend-native': WARNING,
'no-extra-bind': WARNING,
'no-fallthrough': WARNING,
'no-implicit-coercion': OFF,
'no-implied-eval': ERROR,
'no-invalid-this': OFF,
'no-iterator': OFF,
'no-labels': [ERROR, {allowLoop: true, allowSwitch: true}],
'no-lone-blocks': WARNING,
'no-loop-func': OFF,
'no-magic-numbers': OFF,
'no-multi-str': ERROR,
'no-native-reassign': [ERROR, {exceptions: ['Map', 'Set']}],
'no-new-func': ERROR,
'no-new': WARNING,
'no-new-wrappers': WARNING,
'no-octal-escape': WARNING,
'no-octal': WARNING,
'no-param-reassign': OFF,
'no-process-env': OFF,
'no-proto': ERROR,
'no-redeclare': OFF, // TODO should be WARNING?
'no-return-assign': OFF,
'no-script-url': ERROR,
'no-self-compare': WARNING,
'no-sequences': WARNING,
'no-throw-literal': ERROR,
'no-useless-call': WARNING,
'no-void': OFF,
'no-warning-comments': OFF,
'no-with': OFF,
radix: WARNING,
'vars-on-top': OFF,
yoda: OFF,
'init-declarations': OFF,
'no-catch-shadow': ERROR,
'no-delete-var': ERROR,
'no-label-var': WARNING,
'no-shadow-restricted-names': WARNING,
'no-undef-init': OFF,
'no-undef': ERROR,
'no-undefined': OFF,
'callback-return': OFF,
'global-require': OFF,
'handle-callback-err': OFF,
'no-mixed-requires': OFF,
'no-new-require': OFF,
'no-path-concat': OFF,
'no-process-exit': OFF,
'no-restricted-modules': OFF,
'no-sync': OFF,
camelcase: [OFF, {properties: 'always'}],
'consistent-this': [OFF, 'self'],
'func-names': OFF,
'func-style': [OFF, 'declaration'],
'id-length': OFF,
'id-match': OFF,
'max-depth': OFF,
'max-nested-callbacks': OFF,
'max-params': OFF,
'max-statements': OFF,
'new-cap': OFF,
'newline-after-var': OFF,
'no-array-constructor': ERROR,
'no-continue': OFF,
'no-inline-comments': OFF,
'no-lonely-if': OFF,
'no-negated-condition': OFF,
'no-nested-ternary': OFF,
'no-new-object': WARNING,
'no-plusplus': OFF,
'no-ternary': OFF,
'no-underscore-dangle': OFF,
'no-unneeded-ternary': WARNING,
'one-var': [WARNING, {initialized: 'never'}],
'operator-assignment': [WARNING, 'always'],
'require-jsdoc': OFF,
'sort-vars': OFF,
'spaced-comment': [
OFF,
'always',
{exceptions: ['jshint', 'jslint', 'eslint', 'global']},
],
'constructor-super': ERROR,
'no-class-assign': WARNING,
'no-const-assign': ERROR,
'no-dupe-class-members': ERROR,
'no-this-before-super': ERROR,
'object-shorthand': OFF,
'prefer-const': OFF,
'prefer-spread': OFF,
'prefer-reflect': OFF,
'prefer-template': OFF,
'require-yield': OFF,
'babel/generator-star-spacing': OFF,
'babel/new-cap': OFF,
'babel/array-bracket-spacing': OFF,
'babel/object-curly-spacing': OFF,
'babel/object-shorthand': OFF,
'babel/arrow-parens': OFF,
'babel/no-await-in-loop': OFF,
'babel/flow-object-type': OFF,
'react/display-name': OFF,
'react/forbid-prop-types': OFF,
'react/jsx-closing-bracket-location': OFF,
'react/jsx-curly-spacing': OFF,
'react/jsx-equals-spacing': WARNING,
'react/jsx-filename-extension': OFF,
'react/jsx-first-prop-new-line': OFF,
'react/jsx-handler-names': OFF,
'react/jsx-indent': OFF,
'react/jsx-indent-props': OFF,
'react/jsx-key': OFF,
'react/jsx-max-props-per-line': OFF,
'react/jsx-no-bind': OFF,
'react/jsx-no-duplicate-props': ERROR,
'react/jsx-no-literals': OFF,
'react/jsx-no-target-blank': OFF,
'react/jsx-pascal-case': OFF,
'react/jsx-sort-props': OFF,
'react/jsx-uses-vars': ERROR,
'react/no-comment-textnodes': OFF,
'react/no-danger': OFF,
'react/no-deprecated': OFF,
'react/no-did-mount-set-state': OFF,
'react/no-did-update-set-state': OFF,
'react/no-direct-mutation-state': OFF,
'react/no-multi-comp': OFF,
'react/no-render-return-value': OFF,
'react/no-set-state': OFF,
'react/no-string-refs': OFF,
'react/no-unknown-property': OFF,
'react/prefer-es6-class': OFF,
'react/prefer-stateless-function': OFF,
'react/prop-types': OFF,
'react/require-extension': OFF,
'react/require-optimization': OFF,
'react/require-render-return': OFF,
'react/sort-comp': OFF,
'react/sort-prop-types': OFF,
'accessor-pairs': OFF,
'brace-style': [ERROR, '1tbs'],
'consistent-return': OFF,
'dot-location': [ERROR, 'property'],
// We use console['error']() as a signal to not transform it:
'dot-notation': [ERROR, {allowPattern: '^(error|warn)$'}],
'eol-last': ERROR,
eqeqeq: [ERROR, 'allow-null'],
indent: OFF,
'jsx-quotes': [ERROR, 'prefer-double'],
'keyword-spacing': [ERROR, {after: true, before: true}],
'no-bitwise': OFF,
'no-console': OFF,
'no-inner-declarations': [ERROR, 'functions'],
'no-multi-spaces': ERROR,
'no-restricted-globals': [ERROR].concat(restrictedGlobals),
'no-restricted-syntax': [
ERROR,
'WithStatement',
{
selector: 'MemberExpression[property.name=/^(?:substring|substr)$/]',
message: 'Prefer string.slice() over .substring() and .substr().',
},
],
'no-shadow': ERROR,
'no-unused-vars': [ERROR, {args: 'none', ignoreRestSiblings: true}],
'no-use-before-define': OFF,
'no-useless-concat': OFF,
quotes: [ERROR, 'single', {avoidEscape: true, allowTemplateLiterals: true}],
'space-before-blocks': ERROR,
'space-before-function-paren': OFF,
'valid-typeof': [ERROR, {requireStringLiterals: true}],
// Flow fails with non-string literal keys
'no-useless-computed-key': OFF,
// We apply these settings to files that should run on Node.
// They can't use JSX or ES6 modules, and must be in strict mode.
// They can, however, use other ES6 features.
// (Note these rules are overridden later for source files.)
'no-var': ERROR,
strict: ERROR,
// Enforced by Prettier
// TODO: Prettier doesn't handle long strings or long comments. Not a big
// deal. But I turned it off because loading the plugin causes some obscure
// syntax error and it didn't seem worth investigating.
'max-len': OFF,
// React & JSX
// Our transforms set this automatically
'react/jsx-boolean-value': [ERROR, 'always'],
'react/jsx-no-undef': ERROR,
// We don't care to do this
'react/jsx-sort-prop-types': OFF,
'react/jsx-space-before-closing': ERROR,
'react/jsx-uses-react': ERROR,
'react/no-is-mounted': OFF,
// This isn't useful in our test code
'react/react-in-jsx-scope': ERROR,
'react/self-closing-comp': ERROR,
// We don't care to do this
'react/jsx-wrap-multilines': [
ERROR,
{declaration: false, assignment: false},
],
// Prevent for...of loops because they require a Symbol polyfill.
// You can disable this rule for code that isn't shipped (e.g. build scripts and tests).
'no-for-of-loops/no-for-of-loops': ERROR,
// Prevent function declarations after return statements
'no-function-declare-after-return/no-function-declare-after-return': ERROR,
// CUSTOM RULES
// the second argument of warning/invariant should be a literal string
'react-internal/no-primitive-constructors': ERROR,
'react-internal/safe-string-coercion': [
ERROR,
{isProductionUserAppCode: true},
],
'react-internal/no-to-warn-dev-within-to-throw': ERROR,
'react-internal/warning-args': ERROR,
'react-internal/no-production-logging': ERROR,
},
overrides: [
{
// By default, anything error message that appears the packages directory
// must have a corresponding error code. The exceptions are defined
// in the next override entry.
files: ['packages/**/*.js'],
rules: {
'react-internal/prod-error-codes': ERROR,
},
},
{
// These are files where it's OK to have unminified error messages. These
// are environments where bundle size isn't a concern, like tests
// or Node.
files: [
'packages/react-dom/src/test-utils/**/*.js',
'packages/react-devtools-shared/**/*.js',
'packages/react-noop-renderer/**/*.js',
'packages/react-refresh/**/*.js',
'packages/react-server-dom-esm/**/*.js',
'packages/react-server-dom-webpack/**/*.js',
'packages/react-server-dom-turbopack/**/*.js',
'packages/react-server-dom-fb/**/*.js',
'packages/react-test-renderer/**/*.js',
'packages/react-debug-tools/**/*.js',
'packages/react-devtools-extensions/**/*.js',
'packages/react-devtools-timeline/**/*.js',
'packages/react-native-renderer/**/*.js',
'packages/eslint-plugin-react-hooks/**/*.js',
'packages/jest-react/**/*.js',
'packages/internal-test-utils/**/*.js',
'packages/**/__tests__/*.js',
'packages/**/npm/*.js',
],
rules: {
'react-internal/prod-error-codes': OFF,
},
},
{
// We apply these settings to files that we ship through npm.
// They must be ES5.
files: es5Paths,
parser: 'espree',
parserOptions: {
ecmaVersion: 5,
sourceType: 'script',
},
rules: {
'no-var': OFF,
strict: ERROR,
},
},
{
// We apply these settings to the source files that get compiled.
// They can use all features including JSX (but shouldn't use `var`).
files: esNextPaths,
parser: 'hermes-eslint',
parserOptions: {
ecmaVersion: 8,
sourceType: 'module',
},
rules: {
'no-var': ERROR,
'prefer-const': ERROR,
strict: OFF,
},
},
{
files: ['**/__tests__/*.js'],
rules: {
// https://github.com/jest-community/eslint-plugin-jest
// Meh, who cares.
'jest/consistent-test-it': OFF,
// Meh, we have a lot of these, who cares.
'jest/no-alias-methods': OFF,
// We do conditions based on feature flags.
'jest/no-conditional-expect': OFF,
// We have our own assertion helpers.
'jest/expect-expect': OFF,
// Lame rule that fires in itRender helpers or in render methods.
'jest/no-standalone-expect': OFF,
},
},
{
// Rules specific to test setup helper files.
files: [
'**/setupTests.js',
'**/setupEnv.js',
'**/jest/TestFlags.js',
'**/dom-event-testing-library/testHelpers.js',
'**/utils/ReactDOMServerIntegrationTestUtils.js',
'**/babel/transform-react-version-pragma.js',
'**/babel/transform-test-gate-pragma.js',
],
rules: {
// Some helpers intentionally focus tests.
'jest/no-focused-tests': OFF,
// Test fn helpers don't use static text names.
'jest/valid-title': OFF,
// We have our own assertion helpers.
'jest/expect-expect': OFF,
// Some helpers intentionally disable tests.
'jest/no-disabled-tests': OFF,
// Helpers export text function helpers.
'jest/no-export': OFF,
// The examples in comments trigger false errors.
'jest/no-commented-out-tests': OFF,
},
},
{
files: ['**/jest/TestFlags.js'],
rules: {
// The examples in comments trigger false errors.
'jest/no-commented-out-tests': OFF,
},
},
{
files: [
'**/__tests__/**/*.js',
'scripts/**/*.js',
'packages/*/npm/**/*.js',
'packages/dom-event-testing-library/**/*.js',
'packages/react-devtools*/**/*.js',
'dangerfile.js',
'fixtures',
'packages/react-dom/src/test-utils/*.js',
],
rules: {
'react-internal/no-production-logging': OFF,
'react-internal/warning-args': OFF,
'react-internal/safe-string-coercion': [
ERROR,
{isProductionUserAppCode: false},
],
},
},
{
files: [
'scripts/eslint-rules/*.js',
'packages/eslint-plugin-react-hooks/src/*.js',
],
plugins: ['eslint-plugin'],
rules: {
'eslint-plugin/prefer-object-rule': ERROR,
'eslint-plugin/require-meta-fixable': [
ERROR,
{catchNoFixerButFixableProperty: true},
],
'eslint-plugin/require-meta-has-suggestions': ERROR,
},
},
{
files: ['packages/react-native-renderer/**/*.js'],
globals: {
nativeFabricUIManager: 'readonly',
RN$enableMicrotasksInReact: 'readonly',
},
},
{
files: ['packages/react-server-dom-webpack/**/*.js'],
globals: {
__webpack_chunk_load__: 'readonly',
__webpack_require__: 'readonly',
},
},
{
files: ['packages/react-server-dom-turbopack/**/*.js'],
globals: {
__turbopack_load__: 'readonly',
__turbopack_require__: 'readonly',
},
},
{
files: ['packages/scheduler/**/*.js'],
globals: {
TaskController: 'readonly',
},
},
{
files: [
'packages/react-devtools-extensions/**/*.js',
'packages/react-devtools-shared/src/hook.js',
'packages/react-devtools-shared/src/backend/console.js',
'packages/react-devtools-shared/src/backend/shared/DevToolsComponentStackFrame.js',
],
globals: {
__IS_CHROME__: 'readonly',
__IS_FIREFOX__: 'readonly',
__IS_EDGE__: 'readonly',
__IS_NATIVE__: 'readonly',
__IS_INTERNAL_VERSION__: 'readonly',
},
},
{
files: ['packages/react-devtools-shared/**/*.js'],
globals: {
__IS_INTERNAL_VERSION__: 'readonly',
},
},
],
env: {
browser: true,
es6: true,
node: true,
jest: true,
},
globals: {
$Call: 'readonly',
$ElementType: 'readonly',
$Flow$ModuleRef: 'readonly',
$FlowFixMe: 'readonly',
$Keys: 'readonly',
$NonMaybeType: 'readonly',
$PropertyType: 'readonly',
$ReadOnly: 'readonly',
$ReadOnlyArray: 'readonly',
$ArrayBufferView: 'readonly',
$Shape: 'readonly',
CallSite: 'readonly',
ConsoleTask: 'readonly', // TOOD: Figure out what the official name of this will be.
ReturnType: 'readonly',
AnimationFrameID: 'readonly',
// For Flow type annotation. Only `BigInt` is valid at runtime.
bigint: 'readonly',
BigInt: 'readonly',
BigInt64Array: 'readonly',
BigUint64Array: 'readonly',
Class: 'readonly',
ClientRect: 'readonly',
CopyInspectedElementPath: 'readonly',
DOMHighResTimeStamp: 'readonly',
EventListener: 'readonly',
Iterable: 'readonly',
AsyncIterable: 'readonly',
$AsyncIterable: 'readonly',
$AsyncIterator: 'readonly',
Iterator: 'readonly',
AsyncIterator: 'readonly',
IteratorResult: 'readonly',
JSONValue: 'readonly',
JSResourceReference: 'readonly',
MouseEventHandler: 'readonly',
PropagationPhases: 'readonly',
PropertyDescriptor: 'readonly',
React$AbstractComponent: 'readonly',
React$Component: 'readonly',
React$ComponentType: 'readonly',
React$Config: 'readonly',
React$Context: 'readonly',
React$Element: 'readonly',
React$ElementConfig: 'readonly',
React$ElementProps: 'readonly',
React$ElementRef: 'readonly',
React$ElementType: 'readonly',
React$Key: 'readonly',
React$Node: 'readonly',
React$Portal: 'readonly',
React$Ref: 'readonly',
ReadableStreamController: 'readonly',
ReadableStreamReader: 'readonly',
RequestInfo: 'readonly',
RequestOptions: 'readonly',
StoreAsGlobal: 'readonly',
symbol: 'readonly',
SyntheticEvent: 'readonly',
SyntheticMouseEvent: 'readonly',
Thenable: 'readonly',
TimeoutID: 'readonly',
WheelEventHandler: 'readonly',
FinalizationRegistry: 'readonly',
Omit: 'readonly',
spyOnDev: 'readonly',
spyOnDevAndProd: 'readonly',
spyOnProd: 'readonly',
__DEV__: 'readonly',
__EXPERIMENTAL__: 'readonly',
__EXTENSION__: 'readonly',
__PROFILE__: 'readonly',
__TEST__: 'readonly',
__VARIANT__: 'readonly',
__unmockReact: 'readonly',
gate: 'readonly',
trustedTypes: 'readonly',
IS_REACT_ACT_ENVIRONMENT: 'readonly',
AsyncLocalStorage: 'readonly',
async_hooks: 'readonly',
globalThis: 'readonly',
},
};

'use strict';
const {esNextPaths} = require('./scripts/shared/pathsByLanguageVersion');
module.exports = {
plugins: ['prettier-plugin-hermes-parser'],
bracketSpacing: false,
singleQuote: true,
bracketSameLine: true,
trailingComma: 'es5',
printWidth: 80,
parser: 'hermes',
arrowParens: 'avoid',
overrides: [
{
files: ['*.code-workspace'],
options: {
parser: 'json-stringify',
},
},
{
files: esNextPaths,
options: {
trailingComma: 'all',
},
},
{
files: ['*.ts', '*.tsx'],
options: {
trailingComma: 'all',
parser: 'typescript',
},
},
],
};

'use strict';
module.exports = {
plugins: [
'@babel/plugin-syntax-jsx',
'@babel/plugin-transform-flow-strip-types',
['@babel/plugin-proposal-class-properties', {loose: true}],
'syntax-trailing-function-commas',
[
'@babel/plugin-proposal-object-rest-spread',
{loose: true, useBuiltIns: true},
],
['@babel/plugin-transform-template-literals', {loose: true}],
'@babel/plugin-transform-literals',
'@babel/plugin-transform-arrow-functions',
'@babel/plugin-transform-block-scoped-functions',
'@babel/plugin-transform-object-super',
'@babel/plugin-transform-shorthand-properties',
'@babel/plugin-transform-computed-properties',
'@babel/plugin-transform-for-of',
['@babel/plugin-transform-spread', {loose: true, useBuiltIns: true}],
'@babel/plugin-transform-parameters',
['@babel/plugin-transform-destructuring', {loose: true, useBuiltIns: true}],
['@babel/plugin-transform-block-scoping', {throwIfClosureRequired: true}],
],
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
'use strict';
/* eslint-disable no-for-of-loops/no-for-of-loops */
// Hi, if this is your first time editing/reading a Dangerfile, here's a summary:
// It's a JS runtime which helps you provide continuous feedback inside GitHub.
//
// You can see the docs here: http://danger.systems/js/
//
// If you want to test changes Danger, I'd recommend checking out an existing PR
// and then running the `danger pr` command.
//
// You'll need a GitHub token, you can re-use this one:
//
//  0a7d5c3cad9a6dbec2d9 9a5222cf49062a4c1ef7
//
// (Just remove the space)
//
// So, for example:
//
// `DANGER_GITHUB_API_TOKEN=[ENV_ABOVE] yarn danger pr https://github.com/facebook/react/pull/11865
const {markdown, danger, warn} = require('danger');
const {promisify} = require('util');
const glob = promisify(require('glob'));
const gzipSize = require('gzip-size');
const {writeFileSync} = require('fs');
const {readFileSync, statSync} = require('fs');
const BASE_DIR = 'base-build';
const HEAD_DIR = 'build';
const CRITICAL_THRESHOLD = 0.02;
const SIGNIFICANCE_THRESHOLD = 0.002;
const CRITICAL_ARTIFACT_PATHS = new Set([
// We always report changes to these bundles, even if the change is
// insignificant or non-existent.
'oss-stable/react-dom/cjs/react-dom.production.js',
'oss-stable/react-dom/cjs/react-dom-client.production.js',
'oss-experimental/react-dom/cjs/react-dom.production.js',
'oss-experimental/react-dom/cjs/react-dom-client.production.js',
'facebook-www/ReactDOM-prod.classic.js',
'facebook-www/ReactDOM-prod.modern.js',
]);
const kilobyteFormatter = new Intl.NumberFormat('en', {
style: 'unit',
unit: 'kilobyte',
minimumFractionDigits: 2,
maximumFractionDigits: 2,
});
function kbs(bytes) {
return kilobyteFormatter.format(bytes / 1000);
}
const percentFormatter = new Intl.NumberFormat('en', {
style: 'percent',
signDisplay: 'exceptZero',
minimumFractionDigits: 2,
maximumFractionDigits: 2,
});
function change(decimal) {
if (Number === Infinity) {
return 'New file';
}
if (decimal === -1) {
return 'Deleted';
}
if (decimal < 0.0001) {
return '=';
}
return percentFormatter.format(decimal);
}
const header = `
| Name | +/- | Base | Current | +/- gzip | Base gzip | Current gzip |
| ---- | --- | ---- | ------- | -------- | --------- | ------------ |`;
function row(result, baseSha, headSha) {
const diffViewUrl = `https://react-builds.vercel.app/commits/${headSha}/files/${result.path}?compare=${baseSha}`;
const rowArr = [
`| [${result.path}](${diffViewUrl})`,
`**${change(result.change)}**`,
`${kbs(result.baseSize)}`,
`${kbs(result.headSize)}`,
`${change(result.changeGzip)}`,
`${kbs(result.baseSizeGzip)}`,
`${kbs(result.headSizeGzip)}`,
];
return rowArr.join(' | ');
}
(async function () {
// Use git locally to grab the commit which represents the place
// where the branches differ
const upstreamRepo = danger.github.pr.base.repo.full_name;
if (upstreamRepo !== 'facebook/react') {
// Exit unless we're running in the main repo
return;
}
let headSha;
let baseSha;
try {
headSha = String(readFileSync(HEAD_DIR + '/COMMIT_SHA')).trim();
baseSha = String(readFileSync(BASE_DIR + '/COMMIT_SHA')).trim();
} catch {
warn(
"Failed to read build artifacts. It's possible a build configuration " +
'has changed upstream. Try pulling the latest changes from the ' +
'main branch.'
);
return;
}
// Disable sizeBot in a Devtools Pull Request. Because that doesn't affect production bundle size.
const commitFiles = [
...danger.git.created_files,
...danger.git.deleted_files,
...danger.git.modified_files,
];
if (
commitFiles.every(filename => filename.includes('packages/react-devtools'))
)
return;
const resultsMap = new Map();
// Find all the head (current) artifacts paths.
const headArtifactPaths = await glob('**/*.js', {cwd: 'build'});
for (const artifactPath of headArtifactPaths) {
try {
// This will throw if there's no matching base artifact
const baseSize = statSync(BASE_DIR + '/' + artifactPath).size;
const baseSizeGzip = gzipSize.fileSync(BASE_DIR + '/' + artifactPath);
const headSize = statSync(HEAD_DIR + '/' + artifactPath).size;
const headSizeGzip = gzipSize.fileSync(HEAD_DIR + '/' + artifactPath);
resultsMap.set(artifactPath, {
path: artifactPath,
headSize,
headSizeGzip,
baseSize,
baseSizeGzip,
change: (headSize - baseSize) / baseSize,
changeGzip: (headSizeGzip - baseSizeGzip) / baseSizeGzip,
});
} catch {
// There's no matching base artifact. This is a new file.
const baseSize = 0;
const baseSizeGzip = 0;
const headSize = statSync(HEAD_DIR + '/' + artifactPath).size;
const headSizeGzip = gzipSize.fileSync(HEAD_DIR + '/' + artifactPath);
resultsMap.set(artifactPath, {
path: artifactPath,
headSize,
headSizeGzip,
baseSize,
baseSizeGzip,
change: Infinity,
changeGzip: Infinity,
});
}
}
// Check for base artifacts that were deleted in the head.
const baseArtifactPaths = await glob('**/*.js', {cwd: 'base-build'});
for (const artifactPath of baseArtifactPaths) {
if (!resultsMap.has(artifactPath)) {
const baseSize = statSync(BASE_DIR + '/' + artifactPath).size;
const baseSizeGzip = gzipSize.fileSync(BASE_DIR + '/' + artifactPath);
const headSize = 0;
const headSizeGzip = 0;
resultsMap.set(artifactPath, {
path: artifactPath,
headSize,
headSizeGzip,
baseSize,
baseSizeGzip,
change: -1,
changeGzip: -1,
});
}
}
const results = Array.from(resultsMap.values());
results.sort((a, b) => b.change - a.change);
let criticalResults = [];
for (const artifactPath of CRITICAL_ARTIFACT_PATHS) {
const result = resultsMap.get(artifactPath);
if (result === undefined) {
throw new Error(
'Missing expected bundle. If this was an intentional change to the ' +
'build configuration, update Dangerfile.js accordingly: ' +
artifactPath
);
}
criticalResults.push(row(result, baseSha, headSha));
}
let significantResults = [];
for (const result of results) {
// If result exceeds critical threshold, add to top section.
if (
(result.change > CRITICAL_THRESHOLD ||
0 - result.change > CRITICAL_THRESHOLD ||
// New file
result.change === Infinity ||
// Deleted file
result.change === -1) &&
// Skip critical artifacts. We added those earlier, in a fixed order.
!CRITICAL_ARTIFACT_PATHS.has(result.path)
) {
criticalResults.push(row(result, baseSha, headSha));
}
// Do the same for results that exceed the significant threshold. These
// will go into the bottom, collapsed section. Intentionally including
// critical artifacts in this section, too.
if (
result.change > SIGNIFICANCE_THRESHOLD ||
0 - result.change > SIGNIFICANCE_THRESHOLD ||
result.change === Infinity ||
result.change === -1
) {
significantResults.push(row(result, baseSha, headSha));
}
}
const message = `
Comparing: ${baseSha}...${headSha}
## Critical size changes
Includes critical production bundles, as well as any change greater than ${
CRITICAL_THRESHOLD * 100
}%:
${header}
${criticalResults.join('\n')}
## Significant size changes
Includes any change greater than ${SIGNIFICANCE_THRESHOLD * 100}%:
${
significantResults.length > 0
? `
<details>
<summary>Expand to show</summary>
${header}
${significantResults.join('\n')}
</details>
`
: '(No significant changes)'
}
`;
// GitHub comments are limited to 65536 characters.
if (message.length > 65536) {
// Make message available as an artifact
writeFileSync('sizebot-message.md', message);
markdown(
'The size diff is too large to display in a single comment. ' +
`The GitHub action for this pull request contains an artifact called 'sizebot-message.md' with the full message.`
);
} else {
markdown(message);
}
})();

'use strict';
// This module is the single source of truth for versioning packages that we
// publish to npm.
//
// Packages will not be published unless they are added here.
//
// The @latest channel uses the version as-is, e.g.:
//
//   19.0.0
//
// The @canary channel appends additional information, with the scheme
// <version>-<label>-<commit_sha>, e.g.:
//
//   19.0.0-canary-a1c2d3e4
//
// The @experimental channel doesn't include a version, only a date and a sha, e.g.:
//
//   0.0.0-experimental-241c4467e-20200129
const ReactVersion = '19.0.0';
// The label used by the @canary channel. Represents the upcoming release's
// stability. Most of the time, this will be "canary", but we may temporarily
// choose to change it to "alpha", "beta", "rc", etc.
//
// It only affects the label used in the version string. To customize the
// npm dist tags used during publish, refer to .github/workflows/runtime_prereleases_*.yml.
const canaryChannelLabel = 'rc';
// If the canaryChannelLabel is "rc", the build pipeline will use this to build
// an RC version of the packages.
const rcNumber = 0;
const stablePackages = {
'eslint-plugin-react-hooks': '5.1.0',
'jest-react': '0.16.0',
react: ReactVersion,
'react-art': ReactVersion,
'react-dom': ReactVersion,
'react-server-dom-webpack': ReactVersion,
'react-server-dom-turbopack': ReactVersion,
'react-is': ReactVersion,
'react-reconciler': '0.31.0',
'react-refresh': '0.16.0',
'react-test-renderer': ReactVersion,
'use-subscription': '1.10.0',
'use-sync-external-store': '1.4.0',
scheduler: '0.25.0',
};
// These packages do not exist in the @canary or @latest channel, only
// @experimental. We don't use semver, just the commit sha, so this is just a
// list of package names instead of a map.
const experimentalPackages = ['react-markup'];
module.exports = {
ReactVersion,
canaryChannelLabel,
rcNumber,
stablePackages,
experimentalPackages,
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
/**
* Our philosophy for linting is that lints should be very high-signal:
* - Error, don't warn. If it's worth mentioning it's worth fixing.
* - Enable rules that consistently identify real problems. If we frequently would have to
*   disable the rule due to false positives, it isn't high-signal.
* - Enable rules that help improve consistent style (to avoid code review about style rather
*   than substance).
*/
module.exports = {
extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
rules: {
/*
* We prefer using const where variables are not reassigned, but occassional mistakes
* aren't a major issue
*/
"prefer-const": "off",
// Not valuable enough to enable
"no-useless-escape": "off",
/*
* There are valid use cases for loops with constant conditions where the body contains the
* break
*/
"no-constant-condition": "off",
// eslint only knows about builtin control flow (eg throw, return, break) and not custom ones
// like invariant.
"no-fallthrough": "off",
/*
* Low-value: this fires even for declarations that capture references which wouldn't be as
* obvious if the declaration was lifted to the parent root
*/
"no-inner-declarations": "off",
"multiline-comment-style": ["error", "starred-block"],
/**
* We sometimes need to check for control characters in regexes for things like preserving input
* strings
*/
"no-control-regex": "off",
"@typescript-eslint/no-empty-function": "off",
/*
* Explicitly casting to/through any is sometimes required, often for error messages to
* assertExhaustive()
*/
"@typescript-eslint/no-explicit-any": "off",
/*
* We use non-null assertions carefully. Ideally, there would be a TS option to codegen
* a non-null check at the assertion site.
*/
"@typescript-eslint/no-non-null-assertion": "off",
// Being explicit provides value in cases where inference may later change
"@typescript-eslint/no-inferrable-types": "off",
"@typescript-eslint/explicit-function-return-type": "error",
/*
* Unused variables are frequently a bug. Prefix unused variables with an _ to fix, but note
* that eslint won't warn you that an underscore prefixed variable is used and that the prefix
* should be dropped.
*/
"@typescript-eslint/no-unused-vars": [
"error",
{
argsIgnorePattern: "^_",
varsIgnorePattern: "^_",
caughtErrorsIgnorePattern: "^_",
},
],
// Consider enabling for consistency. Ideally violations could be auto-fixed.
"@typescript-eslint/consistent-generic-constructors": [
"off",
"constructor",
],
"@typescript-eslint/array-type": ["error", { default: "generic" }],
"@typescript-eslint/triple-slash-reference": "off",
"@typescript-eslint/no-var-requires": "off",
},
parser: "@typescript-eslint/parser",
plugins: ["@typescript-eslint"],
root: true,
ignorePatterns: ["**/__tests__/**/*", "**/*.d.ts", "**/dist/**/*"],
env: {
node: true,
},
/*
* If rules need to be disabled then the rule is insufficiently high signal
* and should be diasbled altogether or customized (in either case via a standalone PR)
*/
noInlineConfig: true,
reportUnusedDisableDirectives: true,
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = function (api) {
api.cache(true);
return {
presets: ['next/babel'],
plugins: [
[
'babel-plugin-react-compiler',
{
runtimeModule: 'react-compiler-runtime',
},
],
],
};
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
/**
* Sync from <https://github.com/reactjs/reactjs.org/blob/main/beta/colors.js>.
*/
module.exports = {
// Text colors
primary: '#23272F', // gray-90
'primary-dark': '#F6F7F9', // gray-5
secondary: '#404756', // gray-70
'secondary-dark': '#EBECF0', // gray-10
link: '#087EA4', // blue-50
'link-dark': '#149ECA', // blue-40
syntax: '#EBECF0', // gray-10
wash: '#FFFFFF',
'wash-dark': '#23272F', // gray-90
card: '#F6F7F9', // gray-05
'card-dark': '#343A46', // gray-80
highlight: '#E6F7FF', // blue-10
'highlight-dark': 'rgba(88,175,223,.1)',
border: '#EBECF0', // gray-10
'border-dark': '#343A46', // gray-80
'secondary-button': '#EBECF0', // gray-10
'secondary-button-dark': '#404756', // gray-70
// Gray
'gray-95': '#16181D',
'gray-90': '#23272F',
'gray-80': '#343A46',
'gray-70': '#404756',
'gray-60': '#4E5769',
'gray-50': '#5E687E', // unused
'gray-40': '#78839B',
'gray-30': '#99A1B3',
'gray-20': '#BCC1CD',
'gray-10': '#EBECF0',
'gray-5': '#F6F7F9',
// Blue
'blue-60': '#045975',
'blue-50': '#087EA4',
'blue-40': '#149ECA', // Brand Blue
'blue-30': '#58C4DC', // unused
'blue-20': '#ABE2ED',
'blue-10': '#E6F7FF', // todo: doesn't match illustrations
'blue-5': '#E6F6FA',
// Yellow
'yellow-60': '#B65700',
'yellow-50': '#C76A15',
'yellow-40': '#DB7D27', // unused
'yellow-30': '#FABD62', // unused
'yellow-20': '#FCDEB0', // unused
'yellow-10': '#FDE7C7',
'yellow-5': '#FEF5E7',
// Purple
'purple-60': '#2B3491', // unused
'purple-50': '#575FB7',
'purple-40': '#6B75DB',
'purple-30': '#8891EC',
'purple-20': '#C3C8F5', // unused
'purple-10': '#E7E9FB',
'purple-5': '#F3F4FD',
// Green
'green-60': '#2B6E62',
'green-50': '#388F7F',
'green-40': '#44AC99',
'green-30': '#7FCCBF',
'green-20': '#ABDED5',
'green-10': '#E5F5F2',
'green-5': '#F4FBF9',
// RED
'red-60': '#712D28',
'red-50': '#A6423A', // unused
'red-40': '#C1554D',
'red-30': '#D07D77',
'red-20': '#E5B7B3', // unused
'red-10': '#F2DBD9', // unused
'red-5': '#FAF1F0',
// MISC
'code-block': '#99a1b30f', // gray-30 @ 6%
'gradient-blue': '#58C4DC', // Only used for the landing gradient for now.
github: {
highlight: '#fffbdd',
},
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const MonacoWebpackPlugin = require('monaco-editor-webpack-plugin');
const path = require('path');
const nextConfig = {
reactStrictMode: true,
webpack: (config, options) => {
// Load *.d.ts files as strings using https://webpack.js.org/guides/asset-modules/#source-assets.
config.module.rules.push({
test: /\.d\.ts/,
type: 'asset/source',
});
// Monaco Editor
if (!options.isServer) {
config.plugins.push(
new MonacoWebpackPlugin({
languages: ['typescript', 'javascript'],
filename: 'static/[name].worker.js',
})
);
}
config.resolve.alias = {
...config.resolve.alias,
'react-compiler-runtime': path.resolve(
__dirname,
'../../packages/react-compiler-runtime'
),
};
config.resolve.fallback = {
fs: false,
path: false,
os: false,
};
return config;
},
transpilePackages: ['monaco-editor'],
};
module.exports = nextConfig;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import {defineConfig, devices} from '@playwright/test';
import path from 'path';
// Use process.env.PORT by default and fallback to port 3000
const PORT = process.env.PORT || 3000;
// Set webServer.url and use.baseURL with the location of the WebServer respecting the correct set port
const baseURL = `http://localhost:${PORT}`;
// Reference: https://playwright.dev/docs/test-configuration
export default defineConfig({
// Timeout per test
timeout: 30 * 1000,
// Test directory
testDir: path.join(__dirname, '__tests__/e2e'),
// If a test fails, retry it additional 2 times
retries: 2,
// Artifacts folder where screenshots, videos, and traces are stored.
outputDir: 'test-results/',
// Note: we only use text snapshots, so its safe to omit the host environment name
snapshotPathTemplate: '{testDir}/__snapshots__/{testFilePath}/{arg}{ext}',
// Run your local dev server before starting the tests:
// https://playwright.dev/docs/test-advanced#launching-a-development-web-server-during-the-tests
webServer: {
command:
'yarn workspace babel-plugin-react-compiler build && yarn workspace react-compiler-runtime build && yarn dev',
url: baseURL,
timeout: 300 * 1000,
reuseExistingServer: !process.env.CI,
},
use: {
// Use baseURL so to make navigations relative.
// More information: https://playwright.dev/docs/api/class-testoptions#test-options-base-url
baseURL,
// Retry a test if its failing with enabled tracing. This allows you to analyze the DOM, console logs, network traffic etc.
// More information: https://playwright.dev/docs/trace-viewer
trace: 'retry-with-trace',
// All available context options: https://playwright.dev/docs/api/class-browser#browser-new-context
// contextOptions: {
//   ignoreHTTPSErrors: true,
// },
},
projects: [
{
name: 'chromium',
use: {...devices['Desktop Chrome']},
},
// {
//   name: 'Desktop Firefox',
//   use: {
//     ...devices['Desktop Firefox'],
//   },
// },
// {
//   name: 'Desktop Safari',
//   use: {
//     ...devices['Desktop Safari'],
//   },
// },
// Test against mobile viewports.
// {
//   name: "Mobile Chrome",
//   use: {
//     ...devices["Pixel 5"],
//   },
// },
// {
//   name: "Mobile Safari",
//   use: devices["iPhone 12"],
// },
],
});

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = {
plugins: {
tailwindcss: {},
autoprefixer: {},
},
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const defaultTheme = require('tailwindcss/defaultTheme');
const colors = require('./colors');
module.exports = {
content: [
'./app/**/*.{js,ts,jsx,tsx}',
'./pages/**/*.{js,ts,jsx,tsx}',
'./components/**/*.{js,ts,jsx,tsx}',
'./lib/forgetMonacoDiagnostics.ts',
],
theme: {
extend: {
colors,
width: {
toast: 'min(900px, 100vw - 40px)',
'toast-body': 'calc(100% - 60px)',
'toast-title': 'calc(100% - 40px)',
},
height: {
content: 'calc(100vh - 45px)',
monaco: 'calc(100vh - 93px)',
monaco_small: 'calc(100vh - 129px)',
},
fontFamily: {
sans: [
'Optimistic Display',
'-apple-system',
...defaultTheme.fontFamily.sans,
],
},
},
},
plugins: [],
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const {execSync} = require('child_process');
// So that we don't need to check them into the repo.
// See https://github.com/reactjs/reactjs.org/blob/main/beta/scripts/downloadFonts.js.
execSync(
'curl https://conf.reactjs.org/fonts/Optimistic_Display_W_Lt.woff2 --output public/fonts/Optimistic_Display_W_Lt.woff2'
);
execSync(
'curl https://conf.reactjs.org/fonts/Optimistic_Display_W_Md.woff2 --output public/fonts/Optimistic_Display_W_Md.woff2'
);
execSync(
'curl https://conf.reactjs.org/fonts/Optimistic_Display_W_Bd.woff2 --output public/fonts/Optimistic_Display_W_Bd.woff2'
);

function Component() {
let a = 1;
let b;
if (a === 1) {
b = true;
} else {
b = false;
}
let c;
if (b) {
c = "hello";
} else {
c = null;
}
let d;
if (c === "hello") {
d = 42.0;
} else {
d = 42.001;
}
let e;
if (d === 42.0) {
e = "ok";
} else {
e = "nope";
}
// should constant-propagate to "ok"
return e;
}

function Component(props) {
// global propagation
let a;
a = Math;
a; // Math
// primitive propagation w phi
let b;
if (props) {
b = true;
} else {
b = true;
}
b; // true
// primitive propagation fails if different values
let c;
if (props) {
c = true;
} else {
c = 42;
}
c; // <no change>
// constant evaluation
42 + 1; // 43
42 - 1; // 41
42 * 2; // 84
42 / 2; // 21
0 == 1; // false
0 != 1; // true
0 === 1; // false
0 !== 1; // true
0 == 0; // true
// TODO: unary operators
//   0 == -0; // false
//   0 != -0; // true
//   0 === -0; // false
//   0 !== -0; // true
NaN == NaN; // false
NaN != NaN; // true
NaN !== NaN; // true
NaN !== NaN; // true
"hello" == "hello"; // true
"hello" != "hello"; // false
"hello" === "hello"; // true
"hello" !== "hello"; // false
"hello" == "world"; // false
"hello" != "world"; // true
"hello" === "world"; // false
"hello" !== "world"; // true
true == true; // true
true != true; // false
true === true; // true
true !== true; // false
// constant evaluation through variable
let x = 5 * 60 * 60 * 1000; // 5 hours in milliseconds
x;
}

function Component(a, b) {
const [c, , ...d] = a;
const [[[e]], ...[f]] = b;
return [c, d, e, f];
}

function Component(a, b) {
const {
c,
d,
e: { e },
f: { _f: f },
g: {
g: {
g: { g, ...h },
},
},
...i
} = a;
return [c, d, e, f, g, h, i];
}

function foo() {
x = true;
}

function foo() {
let x = 0;
for (let i = 0; i < 10; i = i + 1) {
x = x + i;
}
return x;
}

function Component(props) {
const x = 2;
const foo = function foo(y) {
let a = 1;
let b;
if (a === 1) {
b = 5 + 3;
} else {
b = false;
}
x + y + a + b;
const bar = function bar(z) {
let c = 2;
let d;
d = 3;
x + y + a + b + z + c + d;
};
bar;
foo;
};
}

// import React from "react";
// const FOO = false;
function id(x) {
// React;
// FOO;
Math;
id;
let y = true;
y = false;
y;
let z;
z;
return x;
}

function foo(a, b, c, d) {
if (a) {
return b;
} else {
c;
}
d;
}

function Component(a) {
Math;
let b = 0;
const foo = function foo_(c) {
let d = 1;
return a + b + c + d;
};
return foo();
}

function Component(props) {
let a;
if (props) {
a = 1;
} else {
a = 2;
}
return a;
}

function test() {
[true, false, null, 1, 3.14, ...["hello world!"]];
return 2;
}

function Component(a, b) {
let x;
let y = 0;
let z = 10;
if (a) {
x = 1;
if (b) {
z = 20;
} else {
z = 30;
}
} else {
x = 2;
}
return x + y + z;
}

import { useMemo } from "react";
function Component(x) {
const y = useMemo(() => {
return x;
});
return y;
}

function Component() {
// a's mutable range should be the same as x's mutable range,
// since a is captured into x (which gets mutated later)
let a = someObj();
let x = [];
x.push(a);
mutate(x);
return [x, a];
}

function Component() {
// a's mutable range should be limited
// the following line
let a = someObj();
let x = [];
x.push(a);
return [x, a];
}

function component(a) {
let x = { a };
let y = {};
y.x = x["a"];
mutate(y);
return x;
}

function component() {
let z = [];
let y = {};
y.z = z;
let x = {};
x.y = y;
mutate(x.y.z);
return x;
}

function component() {
let z = [];
let y = {};
y.z = z;
let x = {};
x.y = y;
return x;
}

function foo(cond) {
let a = {};
let b = {};
let c = {};
while (cond) {
let z = a;
a = b;
b = c;
c = z;
mutate(a, b);
}
a;
b;
c;
return a;
}
function mutate(x, y) {}

// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDepNested(props) {
let x = {};
mutate(x);
let y = foo(bar(props.b) + 1);
mutate(x, props.a);
return [x, y];
}

// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDep(props) {
let y = foo(bar(props).b + 1);
return y;
}

function Component(props) {
const ref = useRef(null);
return <Foo ref={ref} />;
}

function foo(a, b, c) {
const x = [a];
const y = [null, b];
const z = [[], [], [c]];
x[0] = y[1];
z[0][0] = x[0];
return [x, z];
}

function Component(props) {
const x = foo(props.x);
const fn = function () {
const arr = [...bar(props)];
return arr.at(x);
};
const fnResult = fn();
return fnResult;
}

// arrayInstance.at should have the following effects:
//  - read on arg0
//  - read on receiver
//  - mutate on lvalue
function ArrayAtTest(props) {
const arr = [foo(props.x)];
const result = arr.at(bar(props.y));
return result;
}

// x's mutable range should extend to `mutate(y)`
function Component(props) {
let x = [42, {}];
const idx = foo(props.b);
let y = x.at(idx);
mutate(y);
return x;
}

function Component(props) {
const x = [0, ...props.foo, null, ...props.bar, "z"];
return x;
}

function Component(props) {
const x = [{}, [], props.value];
const y = x.join(() => "this closure gets stringified, not called");
foo(y);
return [x, y];
}

function Component(props) {
const x = [];
<dif>{x}</dif>;
const y = x.map((item) => item);
return [x, y];
}

function Component(props) {
const x = [];
const y = x.map((item) => {
item.updated = true;
return item;
});
return [x, y];
}

function component([a, b]) {
let y = { a };
let z = { b };
return [y, z];
}

function Component(props) {
const a = [props.a, props.b, "hello"];
const x = a.length;
const y = a.push;
return { a, x, y, z: a.concat };
}

function Component(props) {
const a = [props.a, props.b, "hello"];
const x = a.push(42);
const y = a.at(props.c);
return { a, x, y };
}

// arrayInstance.push should have the following effects:
//  - read on all args (rest parameter)
//  - mutate on receiver
function Component(props) {
const x = foo(props.x);
const y = { y: props.y };
const arr = [];
arr.push({});
arr.push(x, y);
return arr;
}

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export default ErrorView;

function Component(props) {
const x = [props.x];
const index = 0;
x[index] *= 2;
x["0"] += 3;
return x;
}

function g(props) {
const a = { b: { c: props.c } };
a.b.c = a.b.c + 1;
a.b.c *= 2;
return a;
}

function useBar(props) {
let z;
if (props.a) {
if (props.b) {
z = baz();
}
}
return z;
}

function foo() {
const a = [[1]];
const first = a.at(0);
first.set(0, 2);
return a;
}

function g() {
const x = { y: { z: 1 } };
x.y.z = x.y.z + 1;
x.y.z *= 2;
return x;
}

function f() {
let x = 1;
x = x + 1;
x += 1;
x >>>= 1;
return x;
}

async function Component(props) {
const x = [];
await populateData(props.id, x);
return x;
}

async function Component(props) {
const user = await load(props.id);
return <div>{user.name}</div>;
}

import { useState, useMemo } from "react";
function Component(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
function Component2(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}

import * as React from "react";
import { useState, useMemo } from "react";
function Component(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
function Component2(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}

function App({ text, hasDeps }) {
const resolvedText = useMemo(
() => {
return text.toUpperCase();
},
hasDeps ? null : [text] // should be DCE'd
);
return resolvedText;
}

function component(t) {
let { a } = t;
let y = { a };
return y;
}

function Component(props) {
const maybeMutable = new MaybeMutable();
return <div>{maybeMutate(maybeMutable)}</div>;
}

function Component(props) {
let x = makeObject();
x.foo((x = makeObject()));
return x;
}

function Component(props) {
let x = makeObject();
x.foo(([x] = makeObject()));
return x;
}

function Component(props) {
const x = foo(...props.a, null, ...props.b);
return x;
}

function Component(props) {
const x = makeFunction(props);
const y = x(
<div>
<span>{props.text}</span>
</div>
);
return y;
}

function foo() {}
function Component(props) {
const a = [];
const b = {};
foo(a, b);
let _ = <div a={a} />;
foo(b);
return <div a={a} b={b} />;
}

function component(a) {
let x = { a };
(function () {
let q = x;
(function () {
q.b = 1;
})();
})();
return x;
}

function getNativeLogFunction(level) {
return function () {
let str;
if (arguments.length === 1 && typeof arguments[0] === "string") {
str = arguments[0];
} else {
str = Array.prototype.map
.call(arguments, function (arg) {
return inspect(arg, {
depth: 10,
});
})
.join(", ");
}
const firstArg = arguments[0];
let logLevel = level;
if (
typeof firstArg === "string" &&
firstArg.slice(0, 9) === "Warning: " &&
logLevel >= LOG_LEVELS.error
) {
logLevel = LOG_LEVELS.warn;
}
if (global.__inspectorLog) {
global.__inspectorLog(
INSPECTOR_LEVELS[logLevel],
str,
[].slice.call(arguments),
INSPECTOR_FRAMES_TO_SKIP
);
}
if (groupStack.length) {
str = groupFormat("", str);
}
global.nativeLoggingHook(str, logLevel);
};
}

function component(a) {
let z = { a };
(function () {
(function () {
z.b = 1;
})();
})();
return z;
}

function component(a) {
let z = { a };
let x = () => {
console.log(z);
};
return x;
}

function component(foo, bar) {
let x = { foo };
let y = { bar };
(function () {
let a = { y };
let b = x;
a.x = b;
})();
mutate(y);
return x;
}

function component(foo, bar) {
let x = { foo };
let y = { bar };
(function () {
let a = [y];
let b = x;
a.x = b;
})();
mutate(y);
return x;
}

function component(foo, bar) {
let x = { foo };
let y = { bar };
(function () {
let a = [y];
let b = x;
a.x = b;
})();
mutate(y);
return y;
}

function component(foo, bar) {
let x = { foo };
let y = { bar };
(function () {
let a = { y };
let b = x;
a.x = b;
})();
mutate(y);
return y;
}

function component(a) {
let x = { a };
let y = {};
(function () {
y["x"] = x;
})();
mutate(y);
return y;
}

function component(a) {
let x = { a };
let y = {};
(function () {
y.x = x;
})();
mutate(y);
return y;
}

function component(a) {
let x = { a };
let y = {};
(function () {
let a = y;
a["x"] = x;
})();
mutate(y);
return y;
}

function component(a) {
let x = { a };
let y = {};
(function () {
let a = y;
a.x = x;
})();
mutate(y);
return y;
}

function component(a, b) {
let y = { b };
let z = { a };
let x = function () {
z.a = 2;
y.b;
};
x();
return z;
}

function component(a, b) {
let y = { b };
let z = { a };
let x = function () {
z.a = 2;
y.b;
};
return z;
}

function component(a) {
let y = { b: { a } };
let x = function () {
y.b.a = 2;
};
x();
return y;
}

function component(a, b) {
let z = { a };
let y = { b };
let x = function () {
z.a = 2;
console.log(y.b);
};
x();
return z;
}

function component(a) {
let x = { a };
let y = {};
(function () {
y = x;
})();
mutate(y);
return y;
}

function component(a) {
let z = { a };
let x = function () {
console.log(z);
};
return x;
}

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0][1];
})();
return y;
}

function bar(a, b) {
let x = [a, b];
let y = {};
let t = {};
(function () {
y = x[0][1];
t = x[1][0];
})();
return y;
}

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0].a[1];
})();
return y;
}

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0];
})();
return y;
}

function component(a, b) {
let z = { a };
(function () {
mutate(z);
})();
let y = z;
{
// z is shadowed & renamed but the lambda is unaffected.
let z = { b };
y = { y, z };
}
return y;
}

// @debug
function component(a, b) {
let z = { a };
let y = b;
let x = function () {
if (y) {
// we don't know for sure this mutates, so we should assume
// that there is no mutation so long as `x` isn't called
// during render
maybeMutate(z);
}
};
return x;
}

function component(a) {
let t = { a };
function x() {
t.foo();
}
x(t);
return t;
}

function Foo(props) {
const onFoo = useCallback(
(reason) => {
log(props.router.location);
},
[props.router.location]
);
return onFoo;
}

function component({ mutator }) {
const poke = () => {
mutator.poke();
};
const hide = () => {
mutator.user.hide();
};
return <Foo poke={poke} hide={hide}></Foo>;
}

function component(a, b) {
let z = { a };
{
let z = { b };
(function () {
mutate(z);
})();
}
return z;
}

function component(a, b) {
let z = { a };
let p = () => <Foo>{z}</Foo>;
return p();
}

function component(a) {
let z = { a };
let x = function () {
let z;
mutate(z);
};
return x;
}

function StoreLandingUnseenGiftModalContainer(a) {
const giftsSeen = { a };
return ((gift) => (gift.id ? giftsSeen[gift.id] : false))();
}

function component(a) {
let z = { a };
let x;
{
x = function () {
console.log(z);
};
}
return x;
}

function component(a) {
let z = { a };
let x = function () {
console.log(z.a);
};
return x;
}

function component(a) {
let z = { a: { a } };
let x = function () {
z.a.a();
};
return z;
}

function component(a) {
let z = { a: { a } };
let x = function () {
(function () {
console.log(z.a.a);
})();
};
return x;
}

function component(a) {
let z = { a: { a } };
let x = function () {
console.log(z.a.a);
};
return x;
}

function component(a) {
let x = { a };
let y = 1;
(function () {
y = x;
})();
mutate(y);
return y;
}

function component(a) {
let z = { a };
let x = function () {
{
console.log(z);
}
};
return x;
}

function component(a) {
let z = { a };
let x = function () {
(function () {
console.log(z);
})();
};
return x;
}

function Component() {
let x,
y = (x = {});
const foo = () => {
x = getObject();
};
foo();
return [y, x];
}

function foo() {
const x = { x: 0 };
const y = { z: 0 };
const z = { z: 0 };
x.x += y.y *= 1;
z.z += y.y *= x.x &= 3;
return z;
}

// @enableEmitFreeze @instrumentForget
function useFoo(props) {
return foo(props.x);
}

// @enableEmitFreeze true
function MyComponentName(props) {
let x = {};
foo(x, props.a);
foo(x, props.b);
let y = [];
y.push(x);
return y;
}

// @instrumentForget @compilationMode(annotation) @gating
function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

// @instrumentForget @compilationMode(annotation)
function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

function foo(a, b, c) {
label: if (a) {
while (b) {
if (c) {
break label;
}
}
}
return c;
}

function Component(props) {
const items = props.items;
const maxItems = props.maxItems;
const renderedItems = [];
const seen = new Set();
const max = Math.max(0, maxItems);
for (let i = 0; i < items.length; i += 1) {
const item = items.at(i);
if (item == null || seen.has(item)) {
continue;
}
seen.add(item);
renderedItems.push(<div>{item}</div>);
if (renderedItems.length >= max) {
break;
}
}
const count = renderedItems.length;
return (
<div>
<h1>{count} Items</h1>
{renderedItems}
</div>
);
}

// Should print A, B, arg, original
function Component() {
const changeF = (o) => {
o.f = () => console.log("new");
};
const x = {
f: () => console.log("original"),
};
(console.log("A"), x)[(console.log("B"), "f")](
(changeF(x), console.log("arg"), 1)
);
return x;
}

function Component(props) {
const x = foo[props.method](...props.a, null, ...props.b);
return x;
}

function Component(props) {
let a = foo();
// freeze `a` so we know the next line cannot mutate it
<div>{a}</div>;
// b should be dependent on `props.a`
let b = bar(a[props.a] + 1);
return b;
}

function component(a, b) {
let y = { a };
let x = { b };
x["y"] = y;
mutate(x);
return x;
}

function component() {
let [x, setX] = useState(0);
const handler = (v) => setX(v);
return <Foo handler={handler}></Foo>;
}

// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a` as a dependency (since `props.a.b` is
// a conditional dependency, i.e. gated behind control flow)
function Component(props) {
let x = [];
x.push(props.a?.b);
return x;
}

/**
* props.b *does* influence `a`
*/
function Component(props) {
const a = [];
a.push(props.a);
label: {
if (props.b) {
break label;
}
a.push(props.c);
}
a.push(props.d);
return a;
}

/**
* props.b does *not* influence `a`
*/
function ComponentA(props) {
const a_DEBUG = [];
a_DEBUG.push(props.a);
if (props.b) {
return null;
}
a_DEBUG.push(props.d);
return a_DEBUG;
}
/**
* props.b *does* influence `a`
*/
function ComponentB(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
}
a.push(props.d);
return a;
}
/**
* props.b *does* influence `a`, but only in a way that is never observable
*/
function ComponentC(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
return null;
}
a.push(props.d);
return a;
}
/**
* props.b *does* influence `a`
*/
function ComponentD(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
return a;
}
a.push(props.d);
return a;
}

function ComponentA(props) {
const a = [];
const b = [];
if (b) {
a.push(props.p0);
}
if (props.p1) {
b.push(props.p2);
}
return <Foo a={a} b={b} />;
}
function ComponentB(props) {
const a = [];
const b = [];
if (mayMutate(b)) {
a.push(props.p0);
}
if (props.p1) {
b.push(props.p2);
}
return <Foo a={a} b={b} />;
}
function Foo() {}
function mayMutate() {}

function Component(props) {
const [x, setX] = useState(0);
const foo = () => {
setX(1);
};
if (props.cond) {
setX(2);
foo();
}
return x;
}

function Component(props) {
const x = makeObject(props);
// These calls should view x as readonly and be grouped outside of the reactive scope for x:
console.log(x);
console.info(x);
console.warn(x);
console.error(x);
console.trace(x);
console.table(x);
return x;
}

function foo() {
const isX = GLOBAL_IS_X;
const getJSX = () => {
return <Child x={isX}></Child>;
};
const result = getJSX();
return result;
}

function foo() {
const x = 42;
const f = () => {
console.log(x);
};
f();
return x;
}

function Component(props) {
const index = "foo";
const x = {};
x[index] = x[index] + x["bar"];
x[index](props.foo);
return x;
}

function foo() {
let y = 0;
for (const x = 100; x < 10; x) {
y = y + 1;
}
return y;
}

function Component(props) {
const x = 42;
const onEvent = () => {
console.log(x);
};
return <Foo onEvent={onEvent} />;
}

function foo(a, b, c) {
let x;
if (a) {
x = 2 - 1;
} else {
x = 0 + 1;
}
if (x === 1) {
return b;
} else {
return c;
}
}

function foo() {
let x = 100;
let y = 0;
while (x < 10) {
y += 1;
}
return y;
}

function foo() {
const a = 1;
const b = 2;
const c = 3;
const d = a + b;
const e = d * c;
const f = e / d;
const g = f - e;
if (g) {
console.log("foo");
}
const h = g;
const i = h;
const j = i;
return j;
}

function Foo() {}
function Component(props) {
const a = [];
const b = {};
new Foo(a, b);
let _ = <div a={a} />;
new Foo(b);
return <div a={a} b={b} />;
}

// @debug
function Component(props) {
let x = null;
const onChange = (e) => {
console.log(x);
};
x = {};
return <Foo onChange={onChange} />;
}

function component() {
let [x, setX] = useState(0);
const handler = (event) => setX(event.target.value);
return <input onChange={handler} value={x} />;
}

function foo(props) {
let x = 0;
let y = 0;
while (y < props.max) {
x++;
y++;
}
return y;
}

function Component(props) {
const x = [];
debugger;
x.push(props.value);
return x;
}

function Component(props) {
debugger;
if (props.cond) {
debugger;
} else {
while (props.cond) {
debugger;
}
}
debugger;
}

function Component(p) {
let x;
const foo = () => {
x = {};
};
foo();
return x;
}

function Component() {
let x = null;
function foo() {
x = 9;
}
const y = bar(foo);
return <Child y={y} />;
}

function Component(props) {
const x = { a: props.a, b: props.b };
const key = "b";
delete x[key];
return x;
}

function Component(props) {
const x = { a: props.a, b: props.b };
delete x.b;
return x;
}

function foo(a, b) {
const x = [];
x.push(a);
<div>{x}</div>;
const y = [];
if (x.length) {
y.push(x);
}
if (b) {
y.push(b);
}
return y;
}

function foo(x, y, z) {
const items = [z];
items.push(x);
const items2 = [];
if (x) {
items2.push(y);
}
if (y) {
items.push(x);
}
return items2;
}

let someGlobal = {};
function component(a) {
let x = { a, someGlobal };
return x;
}

function foo(props) {
let x, y;
({ x, y } = { x: props.a, y: props.b });
console.log(x); // prevent DCE from eliminating `x` altogether
x = props.c;
return x + y;
}

function Component(props) {
const [[x] = ["default"]] = props.y;
return x;
}

function Component([a = 2]) {
return a;
}

function Component(props) {
let x;
if (props.cond) {
[[x] = ["default"]] = props.y;
} else {
x = props.fallback;
}
return x;
}

function foo(a, b, c) {
let d, g, n, o;
[
d,
[
{
e: { f: g },
},
],
] = a;
({
l: {
m: [[n]],
},
o,
} = b);
return { d, g, n, o };
}

function Component(props) {
const post = useFragment(graphql`...`, props.post);
const allUrls = [];
// `media` and `urls` are exported from the scope that will wrap this code,
// but `comments` is not (it doesn't need to be memoized, bc the callback
// only checks `comments.length`)
// because of the scope, the let declaration for media and urls are lifted
// out of the scope, and the destructure statement ends up turning into
// a reassignment, instead of a const declaration. this means we try to
// reassign `comments` when there's no declaration for it.
const { media = null, comments = [], urls = [] } = post;
const onClick = (e) => {
if (!comments.length) {
return;
}
console.log(comments.length);
};
allUrls.push(...urls);
return <Media media={media} onClick={onClick} />;
}

function Component(props) {
const post = useFragment(graphql`...`, props.post);
const allUrls = [];
// `media` and `urls` are exported from the scope that will wrap this code,
// but `comments` is not (it doesn't need to be memoized, bc the callback
// only checks `comments.length`)
// because of the scope, the let declaration for media and urls are lifted
// out of the scope, and the destructure statement ends up turning into
// a reassignment, instead of a const declaration. this means we try to
// reassign `comments` when there's no declaration for it.
const { media, comments, urls } = post;
const onClick = (e) => {
if (!comments.length) {
return;
}
console.log(comments.length);
};
allUrls.push(...urls);
return <Media media={media} onClick={onClick} />;
}

function Component(props) {
const { x: { y } = { y: "default" } } = props.y;
return y;
}

function Component({ a = 2 }) {
return a;
}

function Component(props) {
const x = [];
x.push(props.value);
const { length: y } = x;
foo(y);
return [x, y];
}

function foo(a, b, c) {
const [
d,
[
{
e: { f },
...g
},
],
...h
] = a;
const {
l: {
m: [[n], ...o],
},
p,
} = b;
return [d, f, g, h, n, o, p];
}

// @memoizeJsxElements false
function Component(props) {
const [name, setName] = useState(null);
const onChange = function (e) {
setName(e.target.value);
};
return (
<form>
<input onChange={onChange} value={name} />
</form>
);
}

function Component(props) {
do {
break;
} while (props.cond);
return props;
}

function Component(props) {
let x = [1, 2, 3];
let ret = [];
do {
let item = x.pop();
ret.push(item * 2);
} while (x.length && props.cond);
return ret;
}

function Component(props) {
let x = [0, 1, 2, 3];
do {
if (x === 0) {
break;
}
mutate(x);
} while (props.cond);
return x;
}

function Component() {
const x = [0, 1, 2, 3];
const ret = [];
do {
const item = x.pop();
if (item === 0) {
continue;
}
ret.push(item / 2);
} while (x.length);
return ret;
}

function Component(props) {
let x = [1, 2, 3];
do {
mutate(x);
break;
} while (props.cond);
return x;
}

function Component() {
let x = [1, 2, 3];
let ret = [];
do {
let item = x.pop();
ret.push(item * 2);
} while (x.length);
return ret;
}

function Component(props) {
let x = 0;
label: if (props.a) {
x = 1;
} else {
if (props.b) {
x = 2;
} else {
break label;
}
x = 3;
}
label2: switch (props.c) {
case "a": {
x = 4;
break;
}
case "b": {
break label2;
}
case "c": {
x = 5;
// intentional fallthrough
}
default: {
x = 6;
}
}
if (props.d) {
return null;
}
return x;
}

function MyApp(props) {
let res;
if (props.cond) {
return;
} else {
res = 1;
}
}

import * as React from "react";
function Component(props) {
const [x] = React.useState(0);
const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
function Component2(props) {
const [x] = React.useState(0);
const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}

function Component(props) {
const logEvent = useLogging(props.appId);
const [currentStep, setCurrentStep] = useState(0);
const onSubmit = (errorEvent) => {
// 2. onSubmit inherits the mutable range of logEvent
logEvent(errorEvent);
// 3. this call then triggers the ValidateNoSetStateInRender check incorrectly, even though
//    onSubmit is not called during render (although it _could_ be, if OtherComponent does so.
//    but we can't tell without x-file analysis)
setCurrentStep(1);
};
switch (currentStep) {
case 0:
return <OtherComponent data={{ foo: "bar" }} />;
case 1:
return <OtherComponent data={{ foo: "joe" }} onSubmit={onSubmit} />;
default:
// 1. logEvent's mutable range is extended to this instruction
logEvent("Invalid step");
return <OtherComponent data={null} />;
}
}

function Component(props) {
let x = makeObject();
x.foo(([[x]] = makeObject()));
return x;
}

// @enableEmitFreeze @instrumentForget
let makeReadOnly = "conflicting identifier";
function useFoo(props) {
return foo(props.x);
}

function component(a) {
let t = { a };
x(t); // hoisted call
function x(p) {
p.foo();
}
return t;
}

function Foo() {
const [x, setX] = React.useState(1);
return x;
}

// @debug
function Component(props) {
const ref = useRef(null);
const value = ref.current;
return value;
}

function Component(props) {
const x = [];
<div>{x}</div>;
x.push(props.value);
return x;
}

function Component(props) {
const x = useState;
const state = x(null);
return state[0];
}

function component(a, b) {
let y = { b };
let z = { a };
let x = function () {
z.a = 2;
y.b;
};
let t = <Foo x={x}></Foo>;
mutate(x); // x should be frozen here
return t;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
x[0] = true;
return x;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
delete x[y];
return x;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
delete x.y;
return x;
}

function useFoo(props) {
[x] = props;
return { x };
}

function Component(props) {
let a;
[a, b] = props.value;
return [a, b];
}

function Component(props) {
const x = {};
let fn;
if (props.cond) {
// mutable
fn = () => {
x.value = props.value;
};
} else {
// immutable
fn = () => {
x.value;
};
}
return fn;
}

function Component(props) {
const x = {};
const onChange = (e) => {
// INVALID! should use copy-on-write and pass the new value
x.value = e.target.value;
setX(x);
};
return <input value={x.value} onChange={onChange} />;
}

function Component(props) {
let x = "";
const onChange = (e) => {
x = e.target.value;
};
return <input value={x} onChange={onChange} />;
}

function Component(props) {
const [x, setX] = useState({ value: "" });
const onChange = (e) => {
// INVALID! should use copy-on-write and pass the new value
x.value = e.target.value;
setX(x);
};
return <input value={x.value} onChange={onChange} />;
}

function Component(props) {
let x = [];
let y = x;
if (props.p1) {
x = [];
}
let _ = <Component x={x} />;
// y is MaybeFrozen at this point, since it may alias to x
// (which is the above line freezes)
y.push(props.p2);
return <Component x={x} y={y} />;
}

function Component(props) {
let x = [];
let _ = <Component x={x} />;
// x is Frozen at this point
x.push(props.p2);
return <div>{_}</div>;
}

function Component(props) {
return foo(useFoo);
}

function Component(props) {
return <Child foo={useFoo} />;
}

function Component(props) {
const ref = useRef(null);
const x = foo(ref);
return x.current;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
x.y = true;
return x;
}

// @debug
function Component(props) {
const ref = useRef(null);
const renderItem = (item) => {
const current = ref.current;
return <Foo item={item} current={current} />;
};
return <Items>{props.items.map((item) => renderItem(item))}</Items>;
}

function Component(props) {
const ref = useRef(null);
return <Foo ref={ref.current} />;
}

function Component(props) {
const ref = useRef(null);
ref.current = props.value;
return ref.current;
}

/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
"use forget";
const x = [];
return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */

function Component(props) {
const x = props.cond ? useA : useB;
return x();
}

function Component(props) {
const [x, setX] = useState(0);
const aliased = setX;
setX(1);
aliased(2);
return x;
}

function Foo({ a }) {
const ref = useRef();
// type information is lost here as we don't track types of fields
const val = { ref };
// without type info, we don't know that val.ref.current is a ref value so we
// *would* end up depending on val.ref.current
// however, this is an instance of accessing a ref during render and is disallowed
// under React's rules, so we reject this input
const x = { a, val: val.ref.current };
return <VideoList videos={x} />;
}

function component(a, b) {
let x = useMemo(async () => {
await a;
}, []);
return x;
}

function component(a, b) {
let x = useMemo((c) => a, []);
return x;
}

// Let's not support identifiers defined after use for now.
function component(a) {
let y = function () {
m(x);
};
let x = { a };
m(x);
return y;
}

let renderCount = 0;
function NoHooks() {
renderCount++;
return <div />;
}

function Component() {
// Cannot assign to globals
someUnknownGlobal = true;
moduleLocal = true;
}

function foo([a, b], { c, d, e = "e" }, f = "f", ...args) {
let i = 0;
var x = [];
class Bar {
#secretSauce = 42;
constructor() {
console.log(this.#secretSauce);
}
}
const g = { b() {}, c: () => {} };
const { z, aa = "aa" } = useCustom();
<Button haha={1}></Button>;
<Button>{/** empty */}</Button>;
const j = function bar([quz, qux], ...args) {};
for (; i < 3; i += 1) {
x.push(i);
}
for (; i < 3; ) {
break;
}
for (;;) {
break;
}
graphql`
${g}
`;
graphql`\\t\n`;
for (c of [1, 2]) {
}
for ([v] of [[1], [2]]) {
}
for ({ v } of [{ v: 1 }, { v: 2 }]) {
}
for (let x in { a: 1 }) {
}
let updateIdentifier = 0;
--updateIdentifier;
++updateIdentifier;
updateIdentifier.y++;
updateIdentifier.y--;
switch (i) {
case 1 + 1: {
}
case foo(): {
}
case x.y: {
}
default: {
}
}
function component(a) {
// Add support for function declarations once we support `var` hoisting.
function t() {}
t();
}
}
let moduleLocal = false;

function Component(props) {
let y = 0;
const [x, setX] = useState(0);
const foo = () => {
setX(1);
y = 1; // TODO: force foo's mutable range to extend, but ideally we can just remove this line
};
foo();
return [x, y];
}

function useFoo(props) {
let x;
[x] = props;
const foo = () => {
x = getX(props);
};
foo();
return { x };
}

function component(a, b) {
// we don't handle generators at all so this test isn't
// useful for now, but adding this test in case we do
// add support for generators in the future.
let x = useMemo(function* () {
yield a;
}, []);
return x;
}

function f(reader) {
const queue = [1, 2, 3];
let value = 0;
let sum = 0;
// BUG: we need to codegen the complex test expression
while ((value = queue.pop()) != null) {
sum += value;
}
return sum;
}

function Component(props) {
const computedKey = props.key;
const { [computedKey]: x } = props.val;
return x;
}

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export default Renderer = (props) => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);

function Component(props) {
// b is an object, must be memoized even though the input is not memoized
const { a, ...b } = props.a;
// d is an array, mut be memoized even though the input is not memoized
const [c, ...d] = props.c;
return <div b={b} d={d}></div>;
}

function foo(a, b, c) {
const x = [];
if (a) {
const y = [];
if (b) {
y.push(c);
}
x.push(<div>{y}</div>);
}
return x;
}

function Component(props) {
const a = [props.a];
const b = [props.b];
const c = [props.c];
// We don't do constant folding for non-primitive values (yet) so we consider
// that any of a, b, or c could return here
return (a && b) || c;
}

function Component(props) {
// a can be independently memoized, is not mutated later
const a = [props.a];
// b and c are interleaved and grouped into a single scope,
// but they are independent values. c does not escape, but
// we need to ensure that a is memoized or else b will invalidate
// on every render since a is a dependency.
const b = [];
const c = {};
c.a = a;
b.push(props.b);
return b;
}

function Component(props) {
// a can be independently memoized, is not mutated later
// but a is a dependnecy of b, which is a dependency of c.
// we have to memoize a to avoid breaking memoization of b,
// to avoid breaking memoization of c.
const a = [props.a];
// a can be independently memoized, is not mutated later,
// but is a dependency of d which is part of c's scope.
// we have to memoize b to avoid breaking memoization of c.
const b = [a];
// c and d are interleaved and grouped into a single scope,
// but they are independent values. d does not escape, but
// we need to ensure that b is memoized or else b will invalidate
// on every render since a is a dependency. we also need to
// ensure that a is memoized, since it's a dependency of b.
const c = [];
const d = {};
d.b = b;
c.push(props.b);
return c;
}

function Component(props) {
// a does not need to be memoized ever, even though it's a
// dependency of c, which exists in a scope that has a memoized
// output. it doesn't need to be memoized bc the value is a primitive type.
const a = props.a + props.b;
// b and c are interleaved and grouped into a single scope,
// but they are independent values. c does not escape, but
// we need to ensure that a is memoized or else b will invalidate
// on every render since a is a dependency.
const b = [];
const c = {};
c.a = a;
b.push(props.c);
return b;
}

function Component(props) {
const x = [props.a];
const y = x ? props.b : props.c;
return y;
}

function Component(props) {
const x = [props.a];
let y;
if (x) {
y = props.b;
} else {
y = props.c;
}
return y;
}

function Component(props) {
const a = [props.a];
let x = props.b;
switch (props.c) {
case a: {
x = props.d;
}
}
return x;
}

function Component(props) {
const a = [props.a];
let x = props.b;
switch (a) {
case true: {
x = props.c;
}
}
return x;
}

function f(y) {
let x = y;
return x + (x = 2) + x;
}

function f() {
let x = 1;
return x + (x = 2) + x;
}

function foo(a, b, c) {
let x = [];
if (a) {
if (b) {
if (c) {
x.push(0);
}
}
}
if (x.length) {
return x;
}
return null;
}

import fbt from "fbt";
function Component(props) {
const text = fbt(
`Hello, ${fbt.param("(key) name", capitalize(props.name))}!`,
"(description) Greeting"
);
return <div>{text}</div>;
}

import fbt from "fbt";
function Component(props) {
const text = fbt(
`${fbt.param("(key) count", props.count)} items`,
"(description) Number of items"
);
return <div>{text}</div>;
}

import fbt from "fbt";
function Component(props) {
return (
<fbt desc={"Dialog to show to user"}>
Hello <fbt:param name="user name">{capitalize(props.name)}</fbt:param>
</fbt>
);
}

import fbt from "fbt";
function Component(props) {
return (
<fbt desc={"Dialog to show to user"}>
Hello <fbt:param name="user name">{props.name}</fbt:param>
</fbt>
);
}

import fbt from "fbt";
export function Component(props) {
let count = 0;
if (props.items) {
count = props.items.length;
}
return (
<View>
{fbt(
`for ${fbt.param("count", count)} experiences`,
`Label for the number of items`,
{ project: "public" }
)}
</View>
);
}

function Component(props) {
let x = 0;
for (let i = 0; i < props.count; ) {
x += i;
i += 1;
continue;
}
return x;
}

function Component(props) {
let x = 0;
for (let i = 0; i < props.count; ) {
x += i;
if (x > 10) {
break;
}
}
return x;
}

function foo(props) {
let y = 0;
for (
let x = 0;
x > props.min && x < props.max;
x += props.cond ? props.increment : 2
) {
x *= 2;
y += x;
}
return y;
}

function Component() {
const x = [];
for (const item of [1, 2]) {
break;
}
return x;
}

function Component() {
const x = [];
for (const item of [1, 2]) {
if (item === 1) {
break;
}
x.push(item);
}
return x;
}

function Component() {
const x = [0, 1, 2, 3];
const ret = [];
for (const item of x) {
if (item === 0) {
continue;
}
ret.push(item / 2);
}
return ret;
}

function Component() {
let x = [];
let items = [{ v: 0 }, { v: 1 }, { v: 2 }];
for (const { v } of items) {
x.push(v * 2);
}
return x;
}

function Component(props) {
const collection = [makeObject()];
const results = [];
for (const item of collection) {
results.push(<div>{mutate(item)}</div>);
}
return <div>{results}</div>;
}

function Component() {
let x = [];
let items = [0, 1, 2];
for (const ii of items) {
x.push(ii * 2);
}
return x;
}

function Component(props) {
for (let i = 0; i < props.count; i++) {
return;
}
}

function Component() {
const a = [];
const b = a;
useFreeze(a);
foo(b); // should be readonly, value is guaranteed frozen via alias
return b;
}
function useFreeze() {}
function foo(x) {}

function component() {
function x(a) {
a.foo();
}
x = {};
return x;
}

function component() {
function x(a) {
a.foo();
}
function x() {}
return x;
}

function component(a) {
let t = { a };
function x(p) {
p.foo();
}
x(t);
return t;
}

function Component(props) {
let x = {};
// onChange should be inferred as immutable, because the value
// it captures (`x`) is frozen by the time the function is referenced
const onChange = (e) => {
maybeMutate(x, e.target.value);
};
if (props.cond) {
<div>{x}</div>;
}
return <Foo value={x} onChange={onChange} />;
}

function Component(props) {
const id = useSelectedEntitytId();
// this example should infer `id` as mutable, and then infer `onLoad` as mutable,
// and be rejected because onLoad cannot be passed as a frozen value in the JSX.
// however, we likely have to allow this example to work, because hook return
// values are generally immutable in practice and are also widely referenced in
// callbacks.
const onLoad = () => {
log(id);
};
return <Foo onLoad={onLoad} />;
}

function Component(props) {
const mutate = (object, key, value) => {
object.updated = true;
object[key] = value;
};
const x = makeObject(props);
mutate(x);
return x;
}

function Component(x = "default", y = [{}]) {
return [x, y];
}

// @gating @compilationMode(annotation)
export default function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
export default function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
export function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
export function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
export function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
export function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
function Bar(props) {
"use forget";
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
"use forget";
return <Foo>{props.bar}</Foo>;
}

function Component(props) {
const maybeMutable = new MaybeMutable();
// NOTE: this will produce invalid output.
// The HIR is roughly:
//                                    mutable range of `maybeMutable`
// StoreLocal maybeMutable = ...
// t0 = LoadGlobal View               <-- View is lowered inside this mutable range
//                                         and thus gets becomes an output of this scope,
//                                         gets promoted to temporary
// t1 = LoadGlobal maybeMutate
// t2 = LoadLocal maybeMutable
// t3 = Call t1(t2)
// t4 = Jsx tag=t0 props=[] children=[t3] <-- `t0` is an invalid tag
return <View>{maybeMutate(maybeMutable)}</View>;
}

function Component(props) {
const x = {};
const y = Boolean(x);
return [x, y];
}

function Component(props) {
const x = {};
const y = Number(x);
return [x, y];
}

function Component(props) {
const x = {};
const y = String(x);
return [x, y];
}

function t(props) {
let x = [, foo, props];
return x;
}

function t(props) {
let [foo, bar, ,] = props;
return foo;
}

function t(props) {
let [, foo, bar] = props;
return foo;
}

function t(props) {
let [, setstate] = useState();
setstate(1);
return props.foo;
}

function useFreeze() {}
function foo() {}
function Component(props) {
const x = [];
const y = useFreeze(x);
foo(y, x);
return (
<Component>
{x}
{y}
</Component>
);
}

function Component(props) {
const user = useFragment(graphql`...`, props.user) ?? {};
return user.name;
}

function Component() {
const a = [];
useFreeze(a); // should freeze
useFreeze(a); // should be readonly
call(a); // should be readonly
return a;
}
function useFreeze(x) {}
function call(x) {}

function Component(props) {
const cond = props.cond;
const x = props.x;
let a;
if (cond) {
a = x;
} else {
a = [];
}
useFreeze(a); // should freeze, value *may* be mutable
useFreeze(a); // should be readonly
call(a); // should be readonly
return a;
}
function useFreeze(x) {}
function call(x) {}

// @enableAssumeHooksFollowRulesOfReact true
function Component(props) {
const x = {};
// In enableAssumeHooksFollowRulesOfReact mode hooks freeze their inputs and return frozen values
const y = useFoo(x);
// Thus both x and y are frozen here, and x can be independently memoized
bar(x, y);
return [x, y];
}

function Component(props) {
const env = useRelayEnvironment();
// Note: this is a class has no mutable methods, ie it always treats `this` as readonly
const mutator = new Mutator(env);
useOtherHook();
// `x` should be independently memoizeable, since foo(x, mutator) cannot mutate
// the mutator.
const x = {};
foo(x, mutator);
return x;
}
class Mutator {}

function Component(props) {
const [value, setValue] = useState(null);
// NOTE: this lambda does not capture any mutable values (only the state setter)
// and thus should be treated as readonly
const onChange = (e) => setValue((value) => value + e.target.value);
useOtherHook();
// x should be independently memoizeable, since foo(x, onChange) cannot modify onChange
const x = {};
foo(x, onChange);
return x;
}

function compute() {}
function mutate() {}
function foo() {}
function Foo() {}
/**
* Should produce 3 scopes:
*
* a: inputs=props.a & props.c; outputs=a
*   a = compute(props.a);
*   if (props.c)
*     mutate(a)
* b: inputs=props.b & props.c; outputs=b
*   b = compute(props.b);
*   if (props.c)
*     mutate(b)
* return: inputs=a, b outputs=return
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
if (props.c) {
mutate(a);
mutate(b);
}
return <Foo a={a} b={b} />;
}

/**
* Should produce 3 scopes:
*
* a: inputs=props.a, outputs=a
*   a = compute(props.a);
* b: inputs=props.b, outputs=b
*   b = compute(props.b);
* return: inputs=a, b outputs=return
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
return <Foo a={a} b={b} />;
}
function compute() {}
function foo() {}
function Foo() {}

function foo(a, b, c) {
const x = { a: a };
// NOTE: this array should memoize independently from x, w only b,c as deps
x.y = [b, c];
return x;
}

// @debug
function Component(props) {
const x = makeObject();
const y = delete x[props.value];
return y;
}

// Check that we correctly resolve type and effect lookups on the javascript
// global object.
function Component(props) {
let neverAliasedOrMutated = foo(props.b);
let primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);
let primitiveVal2 = Infinity;
let primitiveVal3 = globaThis.globalThis.NaN;
// Even though we don't know the function signature of foo,
// we should be able to infer that it does not mutate its inputs.
foo(primitiveVal1, primitiveVal2, primitiveVal3);
return { primitiveVal1, primitiveVal2, primitiveVal3 };
}

function foo(a, b) {
let x;
if (a) {
x = 1;
} else {
x = 2;
}
let y = x;
return y;
}

function Component(props) {
const x = makeObject();
const y = delete x.value;
return y;
}

// @flow
function Component(props) {
// We can infer that `x` is a primitive bc it is aliased to `y`,
// which is used in a binary expression
const x = foo();
const y = (x: any);
y + 1;
return x;
}
function Component(props) {
const item = useFragment(FRAGMENT, props.item);
useFreeze(item);
const count = new MaybeMutable(item);
return (
<View>
<View>
{<span>Text</span>}
{<span>{maybeMutate(count)}</span>}
</View>
</View>
);
}

function Component(props) {
const count = new MaybeMutable();
return (
<View>
<View>
{<span>Text</span>}
{<span>{maybeMutate(count)}</span>}
</View>
</View>
);
}

function compute() {}
function foo() {}
function Foo() {}
/**
* Should produce 1 scope:
*
* return: inputs=props.a & props.b & props.c; outputs=return
*   const a = compute(props.a);
*   const b = compute(props.b);
*   if (props.c)
*     foo(a, b);
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
if (props.c) {
foo(a, b);
}
return <Foo a={a} b={b} />;
}

/**
* Should produce 1 scope:
*
* return: inputs=props.a & props.b; outputs=return
*   const a = compute(props.a);
*   const b = compute(props.b);
*   foo(a, b);
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
foo(a, b);
return <Foo a={a} b={b} />;
}
function compute() {}
function foo() {}
function Foo() {}

function foo(a, b, c) {
let x = null;
label: {
if (a) {
x = b;
break label;
}
x = c;
}
return x;
}

function foo(a, b, c, d) {
let y = [];
label: if (a) {
if (b) {
y.push(c);
break label;
}
y.push(d);
}
return y;
}

function Component(c) {
let x = { c };
mutate(x);
let a = x;
let b = a;
}

// This caused an infinite loop in the compiler
function MyApp(props) {
const y = makeObj();
const tmp = y.a;
const tmp2 = tmp.b;
y.push(tmp2);
return y;
}

export function Component(props) {
return (
<div>
{}
{props.a}
</div>
);
}

function Foo(props) {
return (
<>
Hello {props.greeting}{" "}
<div>
<>Text</>
</div>
</>
);
}

function Component(props) {
const maybeMutable = new MaybeMutable();
return <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;
}

function Component(props) {
return (
<Sathya.Codes.Forget>
<Foo.Bar.Baz />
</Sathya.Codes.Forget>
);
}

function Component(props) {
return <xml:http protocol:version={props.version} />;
}

function Component(props) {
return (
<Component {...props} {...{ bar: props.cond ? props.foo : props.bar }} />
);
}

function Component(props) {
const maybeMutable = new MaybeMutable();
let Tag = props.component;
// NOTE: the order of evaluation in the lowering is incorrect:
// the jsx element's tag observes `Tag` after reassignment, but should observe
// it before the reassignment.
return (
<Tag>
{((Tag = props.alternateComponent), maybeMutate(maybeMutable))}
<Tag />
</Tag>
);
}

function Component(props) {
let Tag = View;
return (
<Tag>
{((Tag = HScroll), props.value)}
<Tag />
</Tag>
);
}

// Here, element should not be memoized independently of aliasedElement, since
// it is captured by fn.
// AnalyzeFunctions currently does not find captured objects.
//  - mutated context refs are declared as `Capture` effect in `FunctionExpression.deps`
//  - all other context refs are left as Unknown. InferReferenceEffects currently demotes
//    them to reads
function CaptureNotMutate(props) {
const idx = foo(props.x);
const element = bar(props.el);
const fn = function () {
const arr = { element };
return arr[idx];
};
const aliasedElement = fn();
mutate(aliasedElement);
return aliasedElement;
}

function Component() {
const x = {};
{
const x = [];
const fn = function () {
mutate(x);
};
fn();
}
return x; // should return {}
}

function f(a) {
let x;
(() => {
x = { a };
})();
return <div x={x} />;
}

function f(a) {
let x;
(() => {
x = {};
})();
// this is not reactive on `x` as `x` is never reactive
return <div x={x} />;
}

// writing to primitives is not a 'mutate' or 'store' to context references,
// under current analysis in AnalyzeFunctions.
// <unknown> $23:TFunction = Function @deps[<unknown>
//   $21:TPrimitive,<unknown> $22:TPrimitive]:
function Component() {
let x = 40;
const fn = function () {
x = x + 1;
};
fn();
return x;
}

function Component() {
const x = {};
{
let x = 56;
const fn = function () {
x = 42;
};
fn();
}
return x; // should return {}
}

import { fbt } from "fbt";
function Component() {
const buttonLabel = () => {
if (!someCondition) {
return <fbt desc="My label">{"Purchase as a gift"}</fbt>;
} else if (
!iconOnly &&
showPrice &&
item?.current_gift_offer?.price?.formatted != null
) {
return (
<fbt desc="Gift button's label">
{"Gift | "}
<fbt:param name="price">
{item?.current_gift_offer?.price?.formatted}
</fbt:param>
</fbt>
);
} else if (!iconOnly && !showPrice) {
return <fbt desc="Gift button's label">{"Gift"}</fbt>;
}
};
return (
<View>
<Button text={buttonLabel()} />
</View>
);
}

function component(props) {
// The mutable range for a extens the entire body.
// commenting out the last line of InferMutableRanges fixes it.
// my guess of what's going on is that a is aliased into the return value object literal,
// and that alias makes it look like the range of a needs to be extended to that point.
// but what's weird is that the end of a's range doesn't quite extend to the object.
let a = props.a || (props.b && props.c && props.d);
let b = (props.a && props.b && props.c) || props.d;
return { a, b };
}

function component(props) {
let a = props.a || (props.b && props.c && props.d);
let b = (props.a && props.b && props.c) || props.d;
return a ? b : props.c;
}

function foo(a, b, c) {
// Construct and freeze x, y
const x = makeObject(a);
const y = makeObject(a);
<div>
{x}
{y}
</div>;
// z should depend on `x`, `y.method`, and `b`
const z = x[y.method](b);
return z;
}

function foo(a, b, c) {
// Construct and freeze x
const x = makeObject(a);
<div>{x}</div>;
// y should depend on `x` and `b`
const method = x.method;
const y = method.call(x, b);
return y;
}

function foo(a, b, c) {
// Construct and freeze x
const x = makeObject(a);
<div>{x}</div>;
// y should depend on `x` and `b`
const y = x.foo(b);
return y;
}

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export const Renderer = (props) => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
const Renderer = (props) => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);
export default Renderer;

function mutate(x, y) {}
function cond(x) {}
function Component(props) {
let a = {};
let b = {};
let c = {};
let d = {};
while (true) {
let z = a;
a = b;
b = c;
c = d;
d = z;
mutate(a, b);
if (cond(a)) {
break;
}
}
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `d`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
mutate(d, null);
}

function mutate(x, y) {}
function Component(props) {
const a = {};
const b = [a]; // array elements alias
const c = {};
const d = { c }; // object values alias
// capture all the values into this object
const x = {};
x.b = b;
const y = mutate(x, d); // mutation aliases the arg and return value
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `x`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
if (y) {
}
// could in theory mutate any of a/b/c/x/z, so the above should be inferred as mutable
mutate(x, null);
}

function mutate() {}
function cond() {}
function Component(props) {
let a = {};
let b = {};
let c = {};
let d = {};
while (true) {
mutate(a, b);
if (cond(a)) {
break;
}
}
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `d`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
mutate(d, null);
}

function Component(props) {
const [x, setX] = useState(null);
const onChange = (e) => {
let x = null; // intentionally shadow the original x
setX((currentX) => currentX + x); // intentionally refer to shadowed x
};
return <input value={x} onChange={onChange} />;
}

// We should codegen nested optional properties correctly
// (i.e. placing `?` in the correct PropertyLoad)
function Component(props) {
let x = foo(props.a?.b.c.d);
return x;
}

function component(props) {
let x = [];
let y = [];
y.push(useHook(props.foo));
x.push(y);
return x;
}

function Component(props) {
const x = new Foo(...props.foo, null, ...[props.bar]);
return x;
}

// Note that `a?.b.c` is semantically different from `(a?.b).c`
// Here, 'props?.a` is an optional chain, and `.b` is an unconditional load
// (nullthrows if a is nullish)
function Component(props) {
let x = (props?.a).b;
return x;
}

function foo(a, b, c, d) {
let x = {};
if (someVal) {
x = { b };
} else {
x = { c };
}
return x;
}

function foo(a, b, c, d) {
let x = {};
if (someVal) {
x = { b };
} else {
x = { c };
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
const y = someObj();
const z = y;
x = z;
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
x = someObj();
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
let z;
if (b) {
const w = someObj();
z = w;
} else {
z = someObj();
}
const y = z;
x = z;
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c) {
const x = { ...a };
x[b] = c[b];
x[1 + 2] = c[b * 4];
}

function Component(props) {
const x = { ["foo"]: props.foo };
return x;
}

function Component(props) {
const x = { ...props.foo };
return x;
}

function component({ a, b }) {
let y = { a };
let z = { b };
return { y, z };
}

function foo(a, b, c) {
const x = a.x;
const y = { ...b.c.d };
y.z = c.d.e;
foo(a.b.c);
[a.b.c];
}

function Component(props) {
return call?.(props.a)?.(props.b)?.(props.c);
}

function Component(props) {
const item = useFragment(graphql`...`, props.item);
return item.items?.map((item) => renderItem(item)) ?? [];
}

function Component(props) {
return foo?.(props);
}

function Component(props) {
const x = makeOptionalFunction(props);
// for a regular call, the JSX element could be independently memoized
// since it is an immutable value. however, because the call is optional,
// we can't extract out independent memoization for the element w/o
// forcing that argument to evaluate unconditionally
const y = x?.(
<div>
<span>{props.text}</span>
</div>
);
return y;
}

function Component(props) {
return props?.items?.map?.(render)?.filter(Boolean) ?? [];
}

function Component(props) {
const x = makeOptionalFunction(props);
const y = makeObject(props);
const z = x?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
let x = a?.b.c[0];
return x;
}

function Component(props) {
const object = makeObject(props);
return object?.[props.key];
}

function Component(props) {
const x = makeObject();
return x?.[foo(props.value)];
}

// Note that `a?.b.c` is semantically different from `(a?.b).c`
// We should codegen the correct member expressions
function Component(props) {
let x = props?.b.c;
let y = props?.b.c.d?.e.f.g?.h;
return { x, y };
}

function Component(props) {
const x = makeObject();
return x.y?.[props.a?.[props.b?.[props.c]]];
}

function Foo(props) {
let x = bar(props.a);
let y = x?.b;
let z = useBar(y);
return z;
}

function Component(props) {
const x = makeObject(props);
const y = makeObject(props);
const z = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
const x = makeOptionalObject(props);
const y = makeObject(props);
const z = x?.method(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
const x = makeOptionalObject(props);
const y = makeObject(props);
const z = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function foo(a, b, c) {
const x = [];
const y = [];
if (x) {
}
y.push(a);
x.push(b);
}

function foo(a, b) {
let x = [];
let y = [];
x.push(a);
y.push(b);
}

function foo(a, b) {
let x = [];
let y = [];
y.push(b);
x.push(a);
}

function foo(a, b, c) {
let x = [];
if (a) {
let y = [];
if (b) {
y.push(c);
}
x.push(<div>{y}</div>);
}
return x;
}

function foo(a, b, c) {
let x = [];
let y = [];
while (c) {
y.push(b);
x.push(a);
}
}

function foo(a, b, c) {
let x = [];
if (a) {
let y = [];
if (b) {
y.push(c);
}
x.push(y);
}
return x;
}

function component(a) {
let x = "foo";
if (a) {
x = "bar";
} else {
x = "baz";
}
let y = x;
mutate(y);
return y;
}

// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
//   y depends on either props.b or props.b + 1
function PrimitiveAsDepNested(props) {
let x = {};
mutate(x);
let y = foo(props.b + 1);
mutate(x, props.a);
return [x, y];
}

// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
//   y depends on either props.b or props.b + 1
function PrimitiveAsDep(props) {
let y = foo(props.b + 1);
return y;
}

function component(a, b) {
let z = { a, b };
let x = function () {
console.log(z);
};
return x;
}

function Component(props) {
const x = {};
const y = [];
x.y = y;
const child = <Component data={y} />;
x.y.push(props.p0);
return <Component data={x}>{child}</Component>;
}

// Should print A, arg, original
function Component() {
const changeF = (o) => {
o.f = () => console.log("new");
};
const x = {
f: () => console.log("original"),
};
(console.log("A"), x).f((changeF(x), console.log("arg"), 1));
return x;
}

function Component(props) {
const x = foo.bar(...props.a, null, ...props.b);
return x;
}

function Component(props) {
return props.post.feedback.comments?.edges?.map(render);
}

function foo() {
let x = {};
let y = [];
let z = {};
y.push(z);
x.y = y;
return x;
}

function foo(a, b, c) {
const x = [];
if (a) {
const y = [];
y.push(b);
x.push(<div>{y}</div>);
} else {
x.push(c);
}
return x;
}

function f(a, b) {
let x = []; // <- x starts being mutable here.
if (a.length === 1) {
if (b) {
x.push(b); // <- x stops being mutable here.
}
}
return <div>{x}</div>;
}

function Component(props) {
// a and b are technically independent, but their mutation is interleaved
// so they are grouped in a single reactive scope. a does not have any
// reactive inputs, but b does. therefore, we have to treat a as reactive,
// since it will be recreated based on a reactive input.
const a = {};
const b = [];
b.push(props.b);
a.a = null;
// because a may recreate when b does, it becomes reactive. we have to recreate
// c if a changes.
const c = [a];
// Example usage that could fail if we didn't treat a as reactive:
//  const [c, a] = Component({b: ...});
//  assert(c[0] === a);
return [c, a];
}

function Component(props) {
const items = bar();
mutate(items[props.key], props.a);
const count = foo(items.length + 1);
return { items, count };
}

function Component(props) {
const items = bar();
mutate(items.a, props.a);
const count = foo(items.length + 1);
return { items, count };
}

function Component(props) {
let x = [];
let foo = () => {
x = {};
};
foo();
return x;
}

function Component(props) {
let x = 5;
let foo = () => {
x = {};
};
foo();
return x;
}

function Component(props) {
return () => {
let str;
if (arguments.length) {
str = arguments[0];
} else {
str = props.str;
}
global.log(str);
};
}

function Component(props) {
let x = [];
x.push(props.p0);
let y = x;
if (props.p1) {
x = [];
}
y.push(props.p2);
return <Component x={x} y={y} />;
}

function foo(a, b, c) {
let x = [];
if (a) {
x.push(a);
}
let y = <div>{x}</div>;
switch (b) {
case 0: {
x = [];
x.push(b);
break;
}
default: {
x = [];
x.push(c);
}
}
return (
<div>
{y}
{x}
</div>
);
}

function Component(props) {
let x = [];
x.push(props.p0);
let y = x;
x = [];
let _ = <Component x={x} />;
y.push(props.p1);
return <Component x={x} y={y} />;
}

function foo() {
(() => foo())();
}

// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths
function TestCondDepInConditionalExpr(props, other) {
const x = foo(other) ? bar(props.a.b) : baz(props.a.b);
return x;
}

// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths
function TestCondDepInDirectIfElse(props, other) {
const x = {};
if (foo(other)) {
x.b = props.a.b;
} else {
x.c = props.a.b;
}
return x;
}

// props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path
function TestCondDepInNestedIfElse(props, other) {
const x = {};
if (foo(other)) {
if (bar()) {
x.a = props.a.b;
}
} else {
x.d = props.a.b;
}
return x;
}

// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths
function TestCondDepInNestedIfElse(props, other) {
const x = {};
if (foo(other)) {
if (bar()) {
x.a = props.a.b;
} else {
x.b = props.a.b;
}
} else if (baz(other)) {
x.c = props.a.b;
} else {
x.d = props.a.b;
}
return x;
}

// props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in every path
function TestCondDepInSwitchMissingCase(props, other) {
const x = {};
switch (foo(other)) {
case 1:
x.a = props.a.b;
break;
case 2:
x.b = 42;
break;
default:
x.c = props.a.b;
break;
}
return x;
}

// props.a.b should NOT be added as a unconditional dependency to the reactive
// scope that produces x if it is not accessed in the default case.
function TestCondDepInSwitchMissingDefault(props, other) {
const x = {};
switch (foo(other)) {
case 1:
x.a = props.a.b;
break;
case 2:
x.b = props.a.b;
break;
}
return x;
}

// props.a.b should be added as a unconditional dependency to the reactive
// scope that produces x, since it is accessed unconditionally in all cfg
// paths
function TestCondDepInSwitch(props, other) {
const x = {};
switch (foo(other)) {
case 1:
x.a = props.a.b;
break;
case 2:
x.b = props.a.b;
break;
default:
x.c = props.a.b;
}
return x;
}

// When an object's properties are only read conditionally, we should
// track the base object as a dependency.
function TestOnlyConditionalDependencies(props, other) {
const x = {};
if (foo(other)) {
x.b = props.a.b;
x.c = props.a.b.c;
}
return x;
}

// When a conditional dependency `props.a.b.c` has no unconditional dependency
// in its subpath or superpath, we should find the nearest unconditional access
// and promote it to an unconditional dependency.
function TestPromoteUnconditionalAccessToDependency(props, other) {
const x = {};
x.a = props.a.a.a;
if (foo(other)) {
x.c = props.a.b.c;
}
return x;
}

// When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`
// ordering of accesses should not matter
function TestConditionalSubpath1(props, other) {
const x = {};
x.b = props.a.b;
if (foo(other)) {
x.a = props.a;
}
return x;
}

// When a conditional dependency `props.a` is a subpath of an unconditional
// dependency `props.a.b`, we can access `props.a` while preserving program
// semantics (with respect to nullthrows).
// deps: {`props.a`, `props.a.b`} can further reduce to just `props.a`
// ordering of accesses should not matter
function TestConditionalSubpath2(props, other) {
const x = {};
if (foo(other)) {
x.a = props.a;
}
x.b = props.a.b;
return x;
}

// When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency
// ordering of accesses should not matter
function TestConditionalSuperpath1(props, other) {
const x = {};
x.a = props.a;
if (foo(other)) {
x.b = props.a.b;
}
return x;
}

// When an unconditional dependency `props.a` is the subpath of a conditional
// dependency `props.a.b`, we can safely overestimate and only track `props.a`
// as a dependency
// ordering of accesses should not matter
function TestConditionalSuperpath2(props, other) {
const x = {};
if (foo(other)) {
x.b = props.a.b;
}
x.a = props.a;
return x;
}

// To preserve the nullthrows behavior and reactive deps of this code,
// Forget needs to add `props.a.b` or a subpath as a dependency.
//
// (1) Since the reactive block producing x unconditionally read props.a.<...>,
//     reading `props.a.b` outside of the block would still preserve nullthrows
//     semantics of source code
// (2) Technically, props.a, props.a.b, and props.a.b.c are all reactive deps.
//     However, `props.a?.b` is only dependent on whether `props.a` is nullish,
//     not its actual value. Since we already preserve nullthrows on `props.a`,
//     we technically do not need to add `props.a` as a dependency.
function Component(props) {
let x = [];
x.push(props.a?.b);
x.push(props.a.b.c);
return x;
}

function Component(props) {
const x = [];
x.push(props.items?.length);
x.push(props.items?.edges?.map?.(render)?.filter?.(Boolean) ?? []);
return x;
}

// Some reactive scopes are created within a conditional. If a child scope
// is within a conditional, its reactive dependencies should be propagated
// as conditionals
//
// In this test:
// ```javascript
// scope @0 (deps=[???] decls=[x]) {
//   const x = {};
//   if (foo) {
//     scope @1 (deps=[props.a.b] decls=[tmp]) {
//       const tmp = bar(props.a.b);
//     }
//     x.a = tmp;
//   }
// }
// return x;
// ```
function TestReactiveDepsInCondScope(props) {
let x = {};
if (foo) {
let tmp = bar(props.a.b);
x.a = tmp;
}
return x;
}

// This tests an optimization, NOT a correctness property.
// When propagating reactive dependencies of an inner scope up to its parent,
// we prefer to retain granularity.
//
// In this test, we check that Forget propagates the inner scope's conditional
// dependencies (e.g. props.a.b) instead of only its derived minimal
// unconditional dependencies (e.g. props).
// ```javascript
//  scope @0 (deps=[???] decls=[x, y]) {
//    let y = {};
//    scope @1 (deps=[props] decls=[x]) {
//      let x = {};
//      if (foo) mutate1(x, props.a.b);
//    }
//    mutate2(y, props.a.b);
//  }
function TestJoinCondDepsInUncondScopes(props) {
let y = {};
let x = {};
if (foo) {
mutate1(x, props.a.b);
}
mutate2(y, props.a.b);
return [x, y];
}

// Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingDescendantTracked(props) {
let x = {};
x.a = props.a.x.y;
x.b = props.b;
x.c = props.a.c.x.y.z;
return x;
}

// Test that we can track non-overlapping dependencies separately.
// (not needed for correctness but for dependency granularity)
function TestNonOverlappingTracked(props) {
let x = {};
x.b = props.a.b;
x.c = props.a.c;
return x;
}

// Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingDescendantTracked(props) {
let x = {};
x.b = props.a.b.c;
x.c = props.a.b.c.x.y;
x.a = props.a;
return x;
}

// Test that we correctly track a subpath if the subpath itself is accessed as
// a dependency
function TestOverlappingTracked(props) {
let x = {};
x.b = props.a.b;
x.c = props.a.c;
x.a = props.a;
return x;
}

// Determine that we only need to track p.a here
// Ordering of access should not matter
function TestDepsSubpathOrder1(props) {
let x = {};
x.b = props.a.b;
x.a = props.a;
x.c = props.a.b.c;
return x;
}

// Determine that we only need to track p.a here
// Ordering of access should not matter
function TestDepsSubpathOrder2(props) {
let x = {};
x.a = props.a;
x.b = props.a.b;
x.c = props.a.b.c;
return x;
}

// Determine that we only need to track p.a here
// Ordering of access should not matter
function TestDepsSubpathOrder3(props) {
let x = {};
x.c = props.a.b.c;
x.a = props.a;
x.b = props.a.b;
return x;
}

// @validateRefAccessDuringRender false
function VideoTab() {
const ref = useRef();
const t = ref.current;
let x = () => {
console.log(t);
};
return <VideoList videos={x} />;
}

// @validateRefAccessDuringRender false
function Foo({ a }) {
const ref = useRef();
const val = ref.current;
const x = { a, val };
return <VideoList videos={x} />;
}

// @validateRefAccessDuringRender false
function VideoTab() {
const ref = useRef();
let x = () => {
console.log(ref.current.x);
};
return <VideoList videos={x} />;
}

// @validateRefAccessDuringRender false
function Foo({ a }) {
const ref = useRef();
const x = { a, val: ref.current };
return <VideoList videos={x} />;
}

function VideoTab() {
const ref = useRef();
let x = () => {
console.log(ref.current);
};
return <VideoList videos={x} />;
}

function VideoTab() {
const ref = useRef();
let x = () => {
ref.current?.x;
};
return <VideoList videos={x} />;
}

function VideoTab() {
const ref = useRef();
let x = () => {
ref.current = 1;
};
return <VideoList videos={x} />;
}

function Component(props) {
const ref = useRef(null);
const onChange = (e) => {
const newValue = e.target.value ?? ref.current;
ref.current = newValue;
};
useEffect(() => {
console.log(ref.current);
});
return <Foo onChange={onChange} />;
}

function Component(props) {
const pattern = /foo/g;
const value = makeValue();
// We treat RegExp instances as mutable objects (bc they are)
// so by default we assume this could be mutating `value`:
if (pattern.test(value)) {
return <div>{value}</div>;
}
return <div>Default</div>;
}

// @disableAllMemoization true
function Component(props) {
const [x, setX] = useState(() => initializeState(props));
const onChange = useCallback((e) => {
setX(e.target.value);
});
const object = { x, onChange };
return useMemo(() => {
const { x, onChange } = object;
return <input value={x} onChange={onChange} />;
}, [x]);
}

// @debug
function Component(a, b) {
let x = [];
let y = [];
let z = foo(a);
if (FLAG) {
x = bar(z);
y = baz(b);
}
return [x, y];
}

function HomeDiscoStoreItemTileRating(props) {
const item = useFragment();
let count = 0;
const aggregates = item?.aggregates || [];
aggregates.forEach((aggregate) => {
count += aggregate.count || 0;
});
return <Text>{count}</Text>;
}

function Component(props) {
const item = props.item;
const thumbnails = [];
const baseVideos = getBaseVideos(item);
useMemo(() => {
baseVideos.forEach((video) => {
const baseVideo = video.hasBaseVideo;
if (Boolean(baseVideo)) {
thumbnails.push({ extraVideo: true });
}
});
});
return <FlatList baseVideos={baseVideos} items={thumbnails} />;
}

function foo(a, b) {
if (a == null) {
return null;
} else {
return b;
}
}

function Component(props) {
if (props.cond) {
return undefined;
}
return props.value;
}

function Component(props) {
let x;
if (props.cond) {
switch (props.test) {
case 0: {
x = props.v0;
break;
}
case 1: {
x = props.v1;
break;
}
case 2: {
}
default: {
x = props.v2;
}
}
} else {
if (props.cond2) {
x = props.b;
} else {
x = props.c;
}
}
x;
}

// note: comments are for the ideal scopes, not what is currently
// emitted
function foo(props) {
// scope 0: deps=[props.a] decl=[x] reassign=none
let x = [];
x.push(props.a);
// scope 1: deps=[x] decl=[header] reassign=none
const header = props.showHeader ? <div>{x}</div> : null;
// scope 2:
// deps=[x, props.b, props.c]
// decl=none
// reassign=[x]
const y = [x]; // y depends on the earlier x
x = []; // x reassigned
y.push(props.b); // interleaved mutation of x/y
x.push(props.c); // interleaved mutation
// scope 3 ...
const content = (
<div>
{x}
{y}
</div>
);
// scope 4 ...
return (
<>
{header}
{content}
</>
);
}

// note: comments are for the ideal scopes, not what is currently
// emitted
function foo(props) {
// scope 0: deps=[props.a] decl=[x] reassign=none
let x = [];
x.push(props.a);
// scope 1: deps=[x] decl=[header] reassign=none
const header = <div>{x}</div>;
// scope 2:
// deps=[x, props.b, props.c]
// decl=none
// reassign=[x]
const y = [x]; // y depends on the earlier x
x = []; // x reassigned
y.push(props.b); // interleaved mutation of x/y
x.push(props.c); // interleaved mutation
// scope 3 ...
const content = (
<div>
{x}
{y}
</div>
);
// scope 4 ...
return (
<>
{header}
{content}
</>
);
}

function sequence(props) {
let x = (null, Math.max(1, 2), foo());
while ((foo(), true)) {
x = (foo(), 2);
}
return x;
}
function foo() {}

function Component() {
let a = 1;
let b;
if (a === 1) {
b = true;
} else {
b = false;
}
let c;
if (b) {
c = "hello";
} else {
c = null;
}
let d;
if (c === "hello") {
d = 42.0;
} else {
d = 42.001;
}
let e;
if (d === 42.0) {
e = "ok";
} else {
e = "nope";
}
// should constant-propagate to "ok"
return e;
}

function mutate() {}
function foo() {
let a = {};
let b = {};
let c = {};
a = b;
b = c;
c = a;
mutate(a, b);
return c;
}

function component() {
let x = function (a) {
a.foo();
};
return x;
}

function foo(a) {
const x = [a.b];
return x;
}

export default function foo(x, y) {
if (x) {
return foo(false, y);
}
return [y * 10];
}

function Component() {
const item = [];
const foo = useCallback(
() => {
item.push(1);
}, // eslint-disable-next-line react-hooks/exhaustive-deps
[]
);
return <Button foo={foo} />;
}

/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
const x = [];
return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */

function Component(props) {
const a = 1;
const b = 2;
const x = [a, b];
return x;
}

// @Pass runMutableRangeAnalysis
function foo() {}
function Component(props) {
const a = [];
const b = {};
foo(a, b);
if (foo()) {
let _ = <div a={a} />;
}
foo(a, b);
return <div a={a} b={b} />;
}

function foo() {}
function Component(props) {
const a = [];
const b = {};
foo(a, b);
let _ = <div a={a} />;
foo(a, b);
return <div a={a} b={b} />;
}

function Component(props) {
let x = 0;
const values = [];
const y = props.a || props.b;
values.push(y);
if (props.c) {
x = 1;
}
values.push(x);
if (props.d) {
x = 2;
}
values.push(x);
return values;
}

function foo() {
let x = 1;
let y = 2;
if (y === 2) {
x = 3;
}
if (y === 3) {
x = 5;
}
y = x;
}

function foo() {
let x = 1;
let y = 2;
if (y === 2) {
x = 3;
}
y = x;
}

function foo(cond) {
let items = [];
for (const item of items) {
let y = 0;
if (cond) {
y = 1;
}
}
return items;
}

function foo() {
let x = 1;
for (let i = 0; i < 10; /* update is intentally a single identifier */ i) {
x += 1;
}
return x;
}

function foo() {
let x = 1;
for (let i = 0; i < 10; i++) {
x += 1;
}
return x;
}

function foo() {
let x = 1;
let y = 2;
if (y) {
let z = x + y;
} else {
let z = x;
}
}

function Component(props) {
let x = [];
let y;
if (props.p0) {
x.push(props.p1);
y = x;
}
return (
<Component>
{x}
{y}
</Component>
);
}

function foo(a, b, c, d) {
let x = 0;
if (true) {
if (true) {
x = a;
} else {
x = b;
}
x;
} else {
if (true) {
x = c;
} else {
x = d;
}
x;
}
return x;
}

// @xonly
function foo(a, b, c) {
let x = 0;
while (a) {
while (b) {
while (c) {
x + 1;
}
}
}
return x;
}

function foo(a, b, c) {
let x = a;
if (b) {
if (c) {
x = c;
}
// TODO: move the return to the end of the function
return x;
}
}

function foo(a, b, c, d, e) {
let x = null;
if (a) {
x = b;
} else {
if (c) {
x = d;
}
}
return x;
}

function Foo() {}
function Component(props) {
const a = [];
const b = {};
let c = new Foo(a, b);
return c;
}

function foo(a, b) {
let x = [];
if (a) {
x = 1;
}
let y = x;
return y;
}

function foo() {
let x = 1;
let y = 2;
if (x > 1) {
x = 2;
} else {
y = 3;
}
let t = { x: x, y: y };
return t;
}

function Component(props) {
const a = 1;
const b = 2;
const x = { a: a, b: b };
return x;
}

function foo(a) {
const b = {};
const x = b;
if (a) {
let y = {};
x.y = y;
} else {
let z = {};
x.z = z;
}
mutate(b); // aliases x, y & z
return x;
}

function foo(a) {
const x = {};
if (a) {
let y = {};
x.y = y;
} else {
let z = {};
x.z = z;
}
return x;
}

function foo(a) {
const x = {};
if (a) {
let y = {};
x.y = y;
} else {
let z = {};
x.z = z;
}
mutate(x);
return x;
}

function foo(a) {
const x = {};
if (a) {
let y = {};
x.y = y;
mutate(y); // aliases x & y, but not z
} else {
let z = {};
x.z = z;
}
return x;
}

function foo() {
const a = {};
const x = a;
const y = {};
y.x = x;
mutate(a); // y & x are aliased to a
return y;
}

function foo() {
const x = [];
const y = { x: x };
y.x.push([]);
return y;
}

function foo() {
const x = [];
const y = {};
y.x = x;
mutate(x);
return y;
}

function foo() {
const a = {};
const y = a;
const x = [];
y.x = x;
mutate(a); // y & x are aliased to a
return y;
}

function foo() {
const x = [];
const y = {};
y.x = x;
mutate(y);
return y;
}

function foo() {
const x = [];
const y = {};
y.x = x;
return y;
}

// Forget should call the original x (x = foo()) to compute result
function Component() {
let x = foo();
let result = x((x = bar()), 5);
return [result, x];
}

function foo(a, b, c) {
let x = 0;
x = a;
x = b;
x = c;
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond ? (({ x } = { x: {} }), ([x] = [[]]), x.push(props.foo)) : null;
mut(x);
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond ? (({ x } = { x: {} }), ([x] = [[]]), x.push(props.foo)) : null;
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
mut(x);
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond ? ((x = {}), (x = []), x.push(props.foo)) : null;
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond
? ((x = {}), (x = []), x.push(props.foo))
: ((x = []), (x = []), x.push(props.bar));
mut(x);
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
props.cond
? ((x = {}), (x = []), x.push(props.foo))
: ((x = []), (x = []), x.push(props.bar));
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
if (props.cond) {
x = {};
x = [];
x.push(props.foo);
} else {
x = [];
x = [];
x.push(props.bar);
}
mut(x);
return x;
}

function foo(props) {
let { x } = { x: [] };
x.push(props.bar);
if (props.cond) {
({ x } = { x: {} });
({ x } = { x: [] });
x.push(props.foo);
}
mut(x);
return x;
}

function foo(props) {
let { x } = { x: [] };
x.push(props.bar);
if (props.cond) {
({ x } = { x: {} });
({ x } = { x: [] });
x.push(props.foo);
}
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
if (props.cond) {
x = {};
x = [];
x.push(props.foo);
}
mut(x);
return x;
}

function foo(props) {
let x = [];
x.push(props.bar);
if (props.cond) {
x = {};
x = [];
x.push(props.foo);
}
return x;
}

function foo() {
let x = 1;
if (x === 1) {
x = 2;
}
return x;
}

function log() {}
function Foo(cond) {
let str = "";
if (cond) {
let str = "other test";
log(str);
} else {
str = "fallthrough test";
}
log(str);
}

function foo(a, b, c, d) {
let x = 0;
if (true) {
if (true) {
x = a;
} else {
x = b;
}
x;
} else {
if (true) {
x = c;
} else {
x = d;
}
x;
}
// note: intentionally no phi here so that there are two distinct phis above
}

function foo() {
let y = 2;
if (y > 1) {
y = 1;
} else {
y = 2;
}
let x = y;
}

function foo() {
let x = 1;
let y = 2;
}

function foo() {
let x = 1;
let y = 2;
if (y) {
let z = x + y;
}
}

function foo() {
let x = 1;
switch (x) {
case 1: {
x = x + 1;
break;
}
case 2: {
x = x + 2;
break;
}
default: {
x = x + 3;
}
}
let y = x;
}

function foo() {
let x = 1;
if (x === 1) {
x = 2;
}
throw x;
}

function foo() {
let x = 1;
while (x < 10) {
x + 1;
}
return x;
}

function foo() {
let x = 1;
while (x < 10) {
x = x + 1;
}
return x;
}

function foo() {
const x = {};
const y = foo(x);
y.mutate();
return x;
}

function Foo() {
const x = {};
const y = new Foo(x);
y.mutate();
return x;
}

function Component(props) {
switch (props.value) {
case Global.Property: {
return true;
}
default: {
return false;
}
}
}

function Component(props) {
let x = [];
let y;
switch (props.p0) {
case 1: {
break;
}
case true: {
x.push(props.p2);
y = [];
}
default: {
break;
}
case false: {
y = x;
break;
}
}
const child = <Component data={x} />;
y.push(props.p4);
return <Component data={y}>{child}</Component>;
}

function foo(x) {
let y;
switch (x) {
case 0: {
y = 0;
}
case 1: {
y = 1;
}
case 2: {
break;
}
case 3: {
y = 3;
break;
}
case 4: {
y = 4;
}
case 5: {
y = 5;
}
default: {
y = 0;
}
}
}

function Component(props) {
let x = [];
let y;
switch (props.p0) {
case true: {
x.push(props.p2);
x.push(props.p3);
y = [];
}
case false: {
y = x;
break;
}
}
const child = <Component data={x} />;
y.push(props.p4);
return <Component data={y}>{child}</Component>;
}

function Component(props) {
const user = useFragment(graphql`fragment on User { name }`, props.user);
return user.name;
}

function component() {
let t = graphql`
fragment List_viewer on Viewer
@argumentDefinitions(
count: {
type: "Int"
defaultValue: 10
directives: ["@int_max_value(logged_in: 10)"]
}
cursor: { type: "ID" }
)
`;
return t;
}

function componentA(props) {
let t = `hello ${props.a}, ${props.b}!`;
t += ``;
return t;
}
function componentB(props) {
let x = useFoo(`hello ${props.a}`);
return x;
}

function Component(props) {
const maybeMutable = new MaybeMutable();
let x = props;
return [x, maybeMutate(maybeMutable)];
}

function component(props) {
// NOTE: the temporary for the leading space was previously dropped
const x = isMenuShown ? <Bar> {props.a ? props.b : props.c}</Bar> : null;
return x;
}

function Component(props) {
const maybeMutable = new MaybeMutable();
let x = props.value;
return [x, maybeMutate(maybeMutable)];
}

function ternary(props) {
let x = 0;
const y = props.a ? (x = 1) : (x = 2);
return x + y;
}

function ternary(props) {
const a = props.a && props.b ? props.c || props.d : props.e ?? props.f;
const b = props.a ? (props.b && props.c ? props.d : props.e) : props.f;
return a ? b : null;
}

function Component(props) {
const start = performance.now();
const now = Date.now();
const time = performance.now() - start;
return (
<div>
rendering took {time} at {now}
</div>
);
}

function Component(props) {
let x = {};
// onChange should be inferred as immutable, because the value
// it captures (`x`) is frozen by the time the function is referenced
const onChange = (e) => {
maybeMutate(x, e.target.value);
};
if (props.cond) {
<div>{x}</div>;
}
// ideally this call would be outside the memoization block for `x`
onChange();
return <Foo value={x} />;
}

function Component(props) {
const data = useFreeze(); // assume this returns {items: Array<{...}>}
// In this call `data` and `data.items` have a read effect *and* the lambda itself
// is readonly (it doesn't capture ony mutable references). Further, we ca
// theoretically determine that the lambda doesn't need to be memoized, since
// data.items is an Array and Array.prototype.map does not capture its input (callback)
// in the return value.
// An observation is that even without knowing the exact type of `data`, if we know
// that it is a plain, readonly javascript object, then we can infer that any `.map()`
// calls *must* be Array.prototype.map (or else they are a runtime error), since no
// other builtin has a .map() function.
const items = data.items.map((item) => <Item item={item} />);
return <div>{items}</div>;
}

function component() {
let x = {};
let p = {};
let q = {};
let y = {};
x.y = y;
p.y = x.y;
q.y = p.y;
mutate(q);
}

function foo(x) {
return x;
}

function component(a, b) {
if (a > b) {
let m = {};
}
}

function component() {
let a = some();
let b = someOther();
if (a > b) {
let m = {};
}
}

// @flow
type Foo = {bar: string};
function Component(props) {
const x = {bar: props.bar};
const y = (x: Foo);
y.bar = 'hello';
const z = (y: Foo);
return z;
}
function component() {
let x = { t: 1 };
let p = x.t;
return p;
}

function component() {
let x = { u: makeSomePrimitive(), v: makeSomePrimitive() };
let u = x.u;
let v = x.v;
if (u > v) {
}
let y = x.u;
let z = x.v;
return z;
}

function component() {
let x = {};
let q = {};
x.t = q;
let z = x.t;
return z;
}

function component() {
let p = makePrimitive();
p + p; // infer p as primitive
let o = {};
let x = {};
x.t = p; // infer x.t as primitive
let z = x.t;
x.t = o; // generalize x.t
let y = x.t;
return y;
}

function component() {
let x = 1;
let y = 2;
return y;
}

function component() {
let x = foo();
let y = foo();
if (x > y) {
let z = {};
}
let z = foo();
return z;
}

function component(a) {
let t = { t: a };
let z = +t.t;
let q = -t.t;
let p = void t.t;
let n = delete t.t;
let m = !t.t;
let e = ~t.t;
let f = typeof t.t;
return { z, p, q, n, m, e, f };
}

function foo(a) {
let x = 0;
bar: {
x = 1;
break bar;
}
return a + x;
}

function Component(props) {
let x = mutate();
let y;
foo(x);
return [y, x];
}

// Forget currently bails out when it detects a potential mutation (Effect.Mutate)
// to an immutable value. This should not apply to unknown / untyped hooks.
// Default feature flags:
// enableAssumeHooksFollowRulesOfReact=false
// enableTreatHooksAsFunctions=true
function Component(props) {
const x = useUnknownHook1(props);
const y = useUnknownHook2(x);
return y;
}

function foo(props) {
const [x, unused, y] = props.a;
return x + y;
}

function foo(props) {
const [x, y, ...z] = props.a;
return x + y;
}

function Component(props) {
let x = 0;
(x = 1) && (x = 2);
return x;
}

function Component(props) {
// unused!
const obj = makeObject();
const obj2 = makeObject();
const _ = (obj.a ?? obj2.b) || props.c;
return null;
}

function Component(props) {
let x = 0;
props.cond ? (x = 1) : (x = 2);
return x;
}

function Foo(props) {
// can't remove `unused` since it affects which properties are copied into `rest`
const { unused, ...rest } = props.a;
return rest;
}

function Foo(props) {
const { x, y, ...z } = props.a;
return x;
}

function Component(props) {
// unused!
const obj = makeObject();
const _ = obj.a?.b?.(props.c);
return null;
}

function Component(props) {
// unused!
const obj = makeObject();
const _ = obj.a ? props.b : props.c;
return null;
}

function foo(props) {
let x = props.x;
let y = x++;
let z = x--;
return { x, y, z };
}

function component() {
const [count, setCount] = useState(0);
const increment = useCallback(() => setCount(count + 1));
return <Foo onClick={increment}></Foo>;
}

function Component(props) {
const dispatch = useDispatch();
useFreeze(dispatch);
// onUpdate should be memoized even though it doesn't
// flow into the return value
const onUpdate = () => {
dispatch({ kind: "update" });
};
useEffect(() => {
onUpdate();
}, [onUpdate]);
return <div />;
}

function Component(props) {
const item = useMutable(props.itemId);
const dispatch = useDispatch();
useFreeze(dispatch);
const exit = useCallback(() => {
dispatch(createExitAction());
}, [dispatch]);
useEffect(() => {
const cleanup = GlobalEventEmitter.addListener("onInput", () => {
if (item.value) {
exit();
}
});
return () => cleanup.remove();
}, [exit, item]);
maybeMutate(item);
return <div />;
}

function Component(props) {
const x = useMemo(() => {
if (props.cond) {
return makeObject(props.a);
}
return makeObject(props.b);
});
return x;
}

function Component(props) {
const [a, b] = useMemo(() => {
const items = [];
const a = makeObject(props.a);
const b = makeObject(props.b);
return [a, b];
});
return [a, b];
}

function component(a, b) {
let x = useMemo(() => {
if (a) {
return { b };
}
}, [a, b]);
return x;
}

function Component(props) {
const x = useMemo(() => {
label: {
if (props.cond) {
break label;
}
return props.a;
}
return props.b;
});
return x;
}

function Component(props) {
const x = useMemo(() => {
label: {
return props.value;
}
});
return x;
}

function Component(props) {
const x = useMemo(() => props.a && props.b);
return x;
}

function Component(props) {
const x = useMemo(() => {
let y = [];
if (props.cond) {
y.push(props.a);
}
if (props.cond2) {
return y;
}
y.push(props.b);
return y;
});
return x;
}

function Component(props) {
const x = useMemo(someHelper, []);
return x;
}

function Component(props) {
const x = useMemo(() => {
if (props.cond) {
if (props.cond) {
}
}
}, [props.cond]);
return x;
}

function component(a) {
let x = useMemo(() => {
mutate(a);
}, []);
return x;
}

function component(a) {
let x = useMemo(() => [a], [a]);
return <Foo x={x}></Foo>;
}

function Component(props) {
const x = useMemo(() => {
switch (props.key) {
case "key": {
return props.value;
}
default: {
return props.defaultValue;
}
}
});
return x;
}

function Component(props) {
const x = useMemo(() => {
let y;
switch (props.switch) {
case "foo": {
return "foo";
}
case "bar": {
y = "bar";
break;
}
default: {
y = props.y;
}
}
return y;
});
return x;
}

function foo(a, b) {
while (a) {
break;
}
return b;
}

function foo(a, b, c, d) {
while (a) {
if (b) {
continue;
}
c();
continue;
}
d();
}

function foo(props) {
let x = 0;
while (x > props.min && x < props.max) {
x *= 2;
}
return x;
}

function foo(a, b) {
let x = 0;
while (a.b.c) {
x += b;
}
return x;
}

function Component() {
let a = 1;
let a = 2; // error
const b = 3;
const b = 4; // error
function foo() {}
function foo() {} // error
try {
} catch (c) {
let c = true; // error
const c = true; // error
function c() {} // error
// class c {} // error
}
}
function Component() {
// error
}
const x = true;
const x = false; // error

function Component(props) {
foo();
if (props) {
{
for (;;) {
while (true) {
do {
function foo() {
bar();
if (props) {
const _ = function bar() {};
}
}
break;
} while (true);
break;
}
break;
}
}
}
}

import Foo from "foo";
import * as Bar from "bar";
import { Baz } from "baz";
function Component(props) {
let g = global;
let y = new Array(props.count);
let s = String("hello");
let b = Boolean(true);
let n = Number(0);
let x = Math.min(props.x, props.y);
setTimeout(() => {}, 0);
setInterval(() => {}, 0);
Foo;
Bar;
Baz;
}

function Component(props) {
let y = 0;
foo: for (let x = 0; x < 10; x++) {
if (x == 7) {
break foo;
}
y = x + y;
continue foo;
}
bar: if (props) {
break bar;
}
}

function Component() {
function foo() {
a;
b;
}
let a;
const b = true;
}

function Component(a) {
Math;
let b = 0;
const foo = function foo_(c) {
let d = 1;
return a + b + c + d;
};
return foo();
}

function Component() {
a; // invalid
if (true) {
a; // invalid
}
for (;;) {
a; // invalid
}
function foo() {
a; // will be a runtime tdz error but we don't detect that statically
}
foo(); // above is a runtime tdz error bc of this call
let a;
}

function Component() {
let a;
{
var a; // error, conflicts when hoisted
}
const b = 1;
{
var b; // error, conflicts
}
{
let c;
var c; // error, conflicts
}
{
const d = 2;
var d; // error, conflicts
}
// there should be one instance of `e`:
var e = 3;
console.log(e); // 3
var e = 4;
console.log(e); // 4
var e;
console.log(e); // 4
}

function Component(props) {
bar;
bar = true;
baz;
baz = false;
function foo() {
bar;
bar = true;
if (props) {
var bar;
}
}
if (props) {
// nest inside a block statement to test that the declaration hoists
var bar;
}
}
var baz;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
/** @type {import('jest').Config} */
const config = {
projects: ['<rootDir>/scripts/jest/*.config.js'],
};
module.exports = config;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import typescript from '@rollup/plugin-typescript';
import {nodeResolve} from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import path from 'path';
import process from 'process';
import terser from '@rollup/plugin-terser';
import prettier from 'rollup-plugin-prettier';
import banner2 from 'rollup-plugin-banner2';
const NO_INLINE = new Set(['@babel/types']);
const DEV_ROLLUP_CONFIG = {
input: 'src/index.ts',
output: {
file: 'dist/index.js',
format: 'cjs',
sourcemap: false,
exports: 'named',
},
plugins: [
typescript({
tsconfig: './tsconfig.json',
compilerOptions: {
noEmit: true,
},
}),
json(),
nodeResolve({
preferBuiltins: true,
resolveOnly: module => NO_INLINE.has(module) === false,
rootDir: path.join(process.cwd(), '..'),
}),
commonjs(),
terser({
format: {
comments: false,
},
compress: false,
mangle: false,
}),
prettier(),
banner2(
() => `/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @lightSyntaxTransform
* @noflow
* @nolint
* @preventMunge
* @preserve-invariant-messages
*/
"use no memo";
`
),
],
};
export default DEV_ROLLUP_CONFIG;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
'use strict';
const {tests} = require('./eslint-plugin-react-hooks-test-cases');
const {
runBabelPluginReactCompiler,
} = require('../dist/Babel/RunReactCompilerBabelPlugin');
const fs = require('fs');
const path = require('path');
const prettier = require('prettier');
const prettierConfigPath = require.resolve('../.prettierrc');
const process = require('process');
const {createHash} = require('crypto');
const {create} = require('domain');
const FIXTURES_DIR = path.join(
process.cwd(),
'src',
'__tests__',
'fixtures',
'compiler',
'rules-of-hooks'
);
const PRETTIER_OPTIONS = prettier.resolveConfig.sync(FIXTURES_DIR, {
config: prettierConfigPath,
});
const fixtures = [];
for (const test of tests.valid) {
fixtures.push({code: test.code, valid: true});
}
for (const test of tests.invalid) {
fixtures.push({code: test.code, valid: false});
}
for (const fixture of fixtures) {
let error = null;
let passes = true;
try {
// Does the fixture pass with hooks validation disabled? if not skip it
runBabelPluginReactCompiler(
fixture.code,
'rules-of-hooks.js',
'typescript',
{
environment: {
validateHooksUsage: false,
},
}
);
// Does the fixture pass with hooks validation enabled?
try {
runBabelPluginReactCompiler(
fixture.code,
'rules-of-hooks.js',
'typescript',
{
environment: {
validateHooksUsage: true,
},
}
);
} catch (e) {
passes = false;
}
} catch (e) {
error = e;
}
let code = fixture.code;
let prefix = '';
if (error !== null) {
prefix = `todo.bail.`;
code = `// @skip\n// Unsupported input\n${code}`;
} else if (fixture.valid === false) {
if (passes) {
prefix = `todo.error.invalid-`;
code = `// @skip\n// Passed but should have failed\n${code}`;
} else {
prefix = `error.invalid-`;
code = `// Expected to fail\n${code}`;
}
} else if (!passes) {
// oops, error when it should have passed
prefix = `todo.`;
code = `// @skip\n// Failed but should have passed\n${code}`;
}
const formatted = prettier.format(code, PRETTIER_OPTIONS);
const hmac = createHash('sha256');
hmac.update(formatted, 'utf8');
let name = `${prefix}rules-of-hooks-${hmac
.digest('hex')
.substring(0, 12)}.js`;
const fixturePath = path.join(FIXTURES_DIR, name);
fs.writeFileSync(fixturePath, formatted, 'utf8');
}

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
'use strict';
// NOTE: Extracted from https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/__tests__/ESLintRulesOfHooks-test.js
/**
* A string template tag that removes padding from the left side of multi-line strings
*/
function normalizeIndent(strings) {
const codeLines = strings[0].split('\n');
const leftPadding = codeLines[1].match(/\s+/)[0];
return codeLines.map(line => line.slice(leftPadding.length)).join('\n');
}
module.exports.tests = {
valid: [
{
code: normalizeIndent`
// Valid because components can use hooks.
function ComponentWithHook() {
useHook();
}
`,
},
{
code: normalizeIndent`
// Valid because components can use hooks.
function createComponentWithHook() {
return function ComponentWithHook() {
useHook();
};
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can use hooks.
function useHookWithHook() {
useHook();
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can use hooks.
function createHook() {
return function useHookWithHook() {
useHook();
}
}
`,
},
{
code: normalizeIndent`
// Valid because components can call functions.
function ComponentWithNormalFunction() {
doSomething();
}
`,
},
{
code: normalizeIndent`
// Valid because functions can call functions.
function normalFunctionWithNormalFunction() {
doSomething();
}
`,
},
{
code: normalizeIndent`
// Valid because functions can call functions.
function normalFunctionWithConditionalFunction() {
if (cond) {
doSomething();
}
}
`,
},
{
code: normalizeIndent`
// Valid because functions can call functions.
function functionThatStartsWithUseButIsntAHook() {
if (cond) {
userFetch();
}
}
`,
},
{
code: normalizeIndent`
// Valid although unconditional return doesn't make sense and would fail other rules.
// We could make it invalid but it doesn't matter.
function useUnreachable() {
return;
useHook();
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function useHook() { useState(); }
const whatever = function useHook() { useState(); };
const useHook1 = () => { useState(); };
let useHook2 = () => useState();
useHook2 = () => { useState(); };
({useHook: () => { useState(); }});
({useHook() { useState(); }});
const {useHook3 = () => { useState(); }} = {};
({useHook = () => { useState(); }} = {});
Namespace.useHook = () => { useState(); };
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function useHook() {
useHook1();
useHook2();
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function createHook() {
return function useHook() {
useHook1();
useHook2();
};
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function useHook() {
useState() && a;
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function useHook() {
return useHook1() + useHook2();
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can call hooks.
function useHook() {
return useHook1(useHook2());
}
`,
},
{
code: normalizeIndent`
// Valid because hooks can be used in anonymous arrow-function arguments
// to forwardRef.
const FancyButton = React.forwardRef((props, ref) => {
useHook();
return <button {...props} ref={ref} />
});
`,
},
{
code: normalizeIndent`
// Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = React.forwardRef(function (props, ref) {
useHook();
return <button {...props} ref={ref} />
});
`,
},
{
code: normalizeIndent`
// Valid because hooks can be used in anonymous function arguments to
// forwardRef.
const FancyButton = forwardRef(function (props, ref) {
useHook();
return <button {...props} ref={ref} />
});
`,
},
{
code: normalizeIndent`
// Valid because hooks can be used in anonymous function arguments to
// React.memo.
const MemoizedFunction = React.memo(props => {
useHook();
return <button {...props} />
});
`,
},
{
code: normalizeIndent`
// Valid because hooks can be used in anonymous function arguments to
// memo.
const MemoizedFunction = memo(function (props) {
useHook();
return <button {...props} />
});
`,
},
{
code: normalizeIndent`
// Valid because classes can call functions.
// We don't consider these to be hooks.
class C {
m() {
this.useHook();
super.useHook();
}
}
`,
},
{
code: normalizeIndent`
// Valid -- this is a regression test.
jest.useFakeTimers();
beforeEach(() => {
jest.useRealTimers();
})
`,
},
{
code: normalizeIndent`
// Valid because they're not matching use[A-Z].
fooState();
_use();
_useState();
use_hook();
// also valid because it's not matching the PascalCase namespace
jest.useFakeTimer()
`,
},
{
code: normalizeIndent`
// Regression test for some internal code.
// This shows how the "callback rule" is more relaxed,
// and doesn't kick in unless we're confident we're in
// a component or a hook.
function makeListener(instance) {
each(pixelsWithInferredEvents, pixel => {
if (useExtendedSelector(pixel.id) && extendedButton) {
foo();
}
});
}
`,
},
{
code: normalizeIndent`
// This is valid because "use"-prefixed functions called in
// unnamed function arguments are not assumed to be hooks.
React.unknownFunction((foo, bar) => {
if (foo) {
useNotAHook(bar)
}
});
`,
},
{
code: normalizeIndent`
// This is valid because "use"-prefixed functions called in
// unnamed function arguments are not assumed to be hooks.
unknownFunction(function(foo, bar) {
if (foo) {
useNotAHook(bar)
}
});
`,
},
{
code: normalizeIndent`
// Regression test for incorrectly flagged valid code.
function RegressionTest() {
const foo = cond ? a : b;
useState();
}
`,
},
{
code: normalizeIndent`
// Valid because exceptions abort rendering
function RegressionTest() {
if (page == null) {
throw new Error('oh no!');
}
useState();
}
`,
},
{
code: normalizeIndent`
// Valid because the loop doesn't change the order of hooks calls.
function RegressionTest() {
const res = [];
const additionalCond = true;
for (let i = 0; i !== 10 && additionalCond; ++i ) {
res.push(i);
}
React.useLayoutEffect(() => {});
}
`,
},
{
code: normalizeIndent`
// Is valid but hard to compute by brute-forcing
function MyComponent() {
// 40 conditions
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
if (c) {} else {}
// 10 hooks
useHook();
useHook();
useHook();
useHook();
useHook();
useHook();
useHook();
useHook();
useHook();
useHook();
}
`,
},
{
code: normalizeIndent`
// Valid because the neither the conditions before or after the hook affect the hook call
// Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors
const useSomeHook = () => {};
const SomeName = () => {
const filler = FILLER ?? FILLER ?? FILLER;
const filler2 = FILLER ?? FILLER ?? FILLER;
const filler3 = FILLER ?? FILLER ?? FILLER;
const filler4 = FILLER ?? FILLER ?? FILLER;
const filler5 = FILLER ?? FILLER ?? FILLER;
const filler6 = FILLER ?? FILLER ?? FILLER;
const filler7 = FILLER ?? FILLER ?? FILLER;
const filler8 = FILLER ?? FILLER ?? FILLER;
useSomeHook();
if (anyConditionCanEvenBeFalse) {
return null;
}
return (
<React.Fragment>
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
{FILLER ? FILLER : FILLER}
</React.Fragment>
);
};
`,
},
{
code: normalizeIndent`
// Valid because the neither the condition nor the loop affect the hook call.
function App(props) {
const someObject = {propA: true};
for (const propName in someObject) {
if (propName === true) {
} else {
}
}
const [myState, setMyState] = useState(null);
}
`,
},
],
invalid: [
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithConditionalHook() {
if (cond) {
useConditionalHook();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
Hook.useState();
Hook._useState();
Hook.use42();
Hook.useHook();
Hook.use_hook();
`,
errors: [],
},
{
code: normalizeIndent`
class C {
m() {
This.useHook();
Super.useHook();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// This is a false positive (it's valid) that unfortunately
// we cannot avoid. Prefer to rename it to not start with "use"
class Foo extends Component {
render() {
if (cond) {
FooStore.useFeatureFlag();
}
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithConditionalHook() {
if (cond) {
Namespace.useConditionalHook();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function createComponent() {
return function ComponentWithConditionalHook() {
if (cond) {
useConditionalHook();
}
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHookWithConditionalHook() {
if (cond) {
useConditionalHook();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function createHook() {
return function useHookWithConditionalHook() {
if (cond) {
useConditionalHook();
}
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithTernaryHook() {
cond ? useTernaryHook() : null;
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function ComponentWithHookInsideCallback() {
useEffect(() => {
useHookInsideCallback();
});
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function createComponent() {
return function ComponentWithHookInsideCallback() {
useEffect(() => {
useHookInsideCallback();
});
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
const ComponentWithHookInsideCallback = React.forwardRef((props, ref) => {
useEffect(() => {
useHookInsideCallback();
});
return <button {...props} ref={ref} />
});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
const ComponentWithHookInsideCallback = React.memo(props => {
useEffect(() => {
useHookInsideCallback();
});
return <button {...props} />
});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function ComponentWithHookInsideCallback() {
function handleClick() {
useState();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's a common misunderstanding.
// We *could* make it valid but the runtime error could be confusing.
function createComponent() {
return function ComponentWithHookInsideCallback() {
function handleClick() {
useState();
}
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function ComponentWithHookInsideLoop() {
while (cond) {
useHookInsideLoop();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function renderItem() {
useState();
}
function List(props) {
return props.items.map(renderItem);
}
`,
errors: [],
},
{
code: normalizeIndent`
// Currently invalid because it violates the convention and removes the "taint"
// from a hook. We *could* make it valid to avoid some false positives but let's
// ensure that we don't break the "renderItem" and "normalFunctionWithConditionalHook"
// cases which must remain invalid.
function normalFunctionWithHook() {
useHookInsideNormalFunction();
}
`,
errors: [],
},
{
code: normalizeIndent`
// These are neither functions nor hooks.
function _normalFunctionWithHook() {
useHookInsideNormalFunction();
}
function _useNotAHook() {
useHookInsideNormalFunction();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function normalFunctionWithConditionalHook() {
if (cond) {
useHookInsideNormalFunction();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHookInLoops() {
while (a) {
useHook1();
if (b) return;
useHook2();
}
while (c) {
useHook3();
if (d) return;
useHook4();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHookInLoops() {
while (a) {
useHook1();
if (b) continue;
useHook2();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useLabeledBlock() {
label: {
if (a) break label;
useHook();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Currently invalid.
// These are variations capturing the current heuristic--
// we only allow hooks in PascalCase or useFoo functions.
// We *could* make some of these valid. But before doing it,
// consider specific cases documented above that contain reasoning.
function a() { useState(); }
const whatever = function b() { useState(); };
const c = () => { useState(); };
let d = () => useState();
e = () => { useState(); };
({f: () => { useState(); }});
({g() { useState(); }});
const {j = () => { useState(); }} = {};
({k = () => { useState(); }} = {});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
if (a) return;
useState();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
if (a) return;
if (b) {
console.log('true');
} else {
console.log('false');
}
useState();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
if (b) {
console.log('true');
} else {
console.log('false');
}
if (a) return;
useState();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
a && useHook1();
b && useHook2();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook() {
try {
f();
useState();
} catch {}
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
function useHook({ bar }) {
let foo1 = bar && useState();
let foo2 = bar || useState();
let foo3 = bar ?? useState();
}
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
const FancyButton = React.forwardRef((props, ref) => {
if (props.fancy) {
useCustomHook();
}
return <button ref={ref}>{props.children}</button>;
});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
const FancyButton = forwardRef(function(props, ref) {
if (props.fancy) {
useCustomHook();
}
return <button ref={ref}>{props.children}</button>;
});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous and might not warn otherwise.
// This *must* be invalid.
const MemoizedButton = memo(function(props) {
if (props.fancy) {
useCustomHook();
}
return <button>{props.children}</button>;
});
`,
errors: [],
},
{
code: normalizeIndent`
// This is invalid because "use"-prefixed functions used in named
// functions are assumed to be hooks.
React.unknownFunction(function notAComponent(foo, bar) {
useProbablyAHook(bar)
});
`,
errors: [],
},
{
code: normalizeIndent`
// Invalid because it's dangerous.
// Normally, this would crash, but not if you use inline requires.
// This *must* be invalid.
// It's expected to have some false positives, but arguably
// they are confusing anyway due to the use*() convention
// already being associated with Hooks.
useState();
if (foo) {
const foo = React.useCallback(() => {});
}
useCustomHook();
`,
errors: [],
},
{
code: normalizeIndent`
// Technically this is a false positive.
// We *could* make it valid (and it used to be).
//
// However, top-level Hook-like calls can be very dangerous
// in environments with inline requires because they can mask
// the runtime error by accident.
// So we prefer to disallow it despite the false positive.
const {createHistory, useBasename} = require('history-2.1.2');
const browserHistory = useBasename(createHistory)({
basename: '/',
});
`,
errors: [],
},
{
code: normalizeIndent`
class ClassComponentWithFeatureFlag extends React.Component {
render() {
if (foo) {
useFeatureFlag();
}
}
}
`,
errors: [],
},
{
code: normalizeIndent`
class ClassComponentWithHook extends React.Component {
render() {
React.useState();
}
}
`,
errors: [],
},
{
code: normalizeIndent`
(class {useHook = () => { useState(); }});
`,
errors: [],
},
{
code: normalizeIndent`
(class {useHook() { useState(); }});
`,
errors: [],
},
{
code: normalizeIndent`
(class {h = () => { useState(); }});
`,
errors: [],
},
{
code: normalizeIndent`
(class {i() { useState(); }});
`,
errors: [],
},
],
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const makeE2EConfig = require('../jest/makeE2EConfig');
module.exports = makeE2EConfig('e2e no forget', false);

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const makeE2EConfig = require('../jest/makeE2EConfig');
const config = makeE2EConfig('e2e with forget', true);
config.setupFilesAfterEnv = ['<rootDir>/../scripts/jest/setupEnvE2E.js'];
module.exports = config;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = {
displayName: 'main',
preset: 'ts-jest',
rootDir: '../../src',
testPathIgnorePatterns: ['e2e', 'TestDriver', 'test-utils', 'fixtures'],
globals: {
__DEV__: true,
},
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = function makeE2EConfig(displayName, useForget) {
return {
displayName,
testEnvironment: 'jsdom',
rootDir: '../../src',
testMatch: ['**/*.e2e.(js|tsx)'],
modulePathIgnorePatterns: [
// ignore snapshots from the opposite forget configuration
useForget ? '.*\\.no-forget\\.snap$' : '.*\\.with-forget\\.snap$',
// ignore snapshots from the main project
'.*\\.ts\\.snap$',
],
globals: {
__FORGET__: useForget,
},
snapshotResolver: useForget
? '<rootDir>/../scripts/jest/snapshot-resolver-with-forget.js'
: '<rootDir>/../scripts/jest/snapshot-resolver-no-forget.js',
transform: {
'\\.[tj]sx?$': useForget
? '<rootDir>/../scripts/jest/transform-with-forget'
: '<rootDir>/../scripts/jest/transform-no-forget',
},
transformIgnorePatterns: ['/node_modules/'],
};
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = function makeSnapshotResolver(useForget) {
const modeExtension = useForget ? '.with-forget' : '.no-forget';
return {
resolveSnapshotPath: (testPath, snapshotExtension) =>
testPath + modeExtension + snapshotExtension,
resolveTestPath: (snapshotFilePath, snapshotExtension) =>
snapshotFilePath.slice(
0,
-modeExtension.length - snapshotExtension.length
),
testPathForConsistencyCheck: 'some/__tests__/example.test.js',
};
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const ReactCompilerRuntime = require('react/compiler-runtime');
/*
* Our e2e babel transform currently only compiles functions, not programs.
* As a result, our e2e transpiled code does not contain an import for the
* memo cache function. As a temporary hack, we add a `_c` global, which is
* the name that is used for the import by default.
*/
globalThis._c = ReactCompilerRuntime.c;

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const makeSnapshotResolver = require('./makeSnapshotResolver');
module.exports = makeSnapshotResolver(false);

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const makeSnapshotResolver = require('./makeSnapshotResolver');
module.exports = makeSnapshotResolver(true);

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = require('./makeTransform')(false);

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
module.exports = require('./makeTransform')(true);

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import * as React from 'react';
import {render} from '@testing-library/react';
globalThis.constantValue = 'global test value';
test('literal-constant-propagation', () => {
function Component() {
const x = 'test value 1';
return <div>{x}</div>;
}
const {asFragment, rerender} = render(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
rerender(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
});
test('global-constant-propagation', () => {
function Component() {
const x = constantValue;
return <div>{x}</div>;
}
const {asFragment, rerender} = render(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
global test value
</div>
</DocumentFragment>
`);
rerender(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
global test value
</div>
</DocumentFragment>
`);
});
test('lambda-constant-propagation', () => {
function Component() {
const x = 'test value 1';
const getDiv = () => <div>{x}</div>;
return getDiv();
}
const {asFragment, rerender} = render(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
rerender(<Component />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
});
test('lambda-constant-propagation-of-phi-node', () => {
function Component({noopCallback}) {
const x = 'test value 1';
if (constantValue) {
noopCallback();
}
for (let i = 0; i < 5; i++) {
if (!constantValue) {
noopCallback();
}
}
const getDiv = () => <div>{x}</div>;
return getDiv();
}
const {asFragment, rerender} = render(<Component noopCallback={() => {}} />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
rerender(<Component noopCallback={() => {}} />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
test value 1
</div>
</DocumentFragment>
`);
});

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const logs = [];
export function log(message) {
logs.push(message);
}
export function expectLogsAndClear(expected) {
expect(logs).toEqual(expected);
logs.length = 0;
}

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import * as React from 'react';
import {render} from '@testing-library/react';
import {expectLogsAndClear, log} from './expectLogs';
function Hello({name}) {
const items = [1, 2, 3].map(item => {
log(`recomputing ${item}`);
return <div key={item}>Item {item}</div>;
});
return (
<div>
Hello<b>{name}</b>
{items}
</div>
);
}
test('hello', () => {
const {asFragment, rerender} = render(<Hello name="World" />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
Hello
<b>
World
</b>
<div>
Item 1
</div>
<div>
Item 2
</div>
<div>
Item 3
</div>
</div>
</DocumentFragment>
`);
expectLogsAndClear(['recomputing 1', 'recomputing 2', 'recomputing 3']);
rerender(<Hello name="Universe" />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
Hello
<b>
Universe
</b>
<div>
Item 1
</div>
<div>
Item 2
</div>
<div>
Item 3
</div>
</div>
</DocumentFragment>
`);
expectLogsAndClear(
__FORGET__ ? [] : ['recomputing 1', 'recomputing 2', 'recomputing 3']
);
});

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import {render} from '@testing-library/react';
import * as React from 'react';
function Button({label}) {
const theme = useTheme();
const style = computeStyle(theme);
return <button color={style}>{label}</button>;
}
let currentTheme = 'light';
function useTheme() {
return currentTheme;
}
let styleComputations = 0;
function computeStyle(theme) {
styleComputations++;
return theme === 'light' ? 'white' : 'black';
}
test('update-button', () => {
const {asFragment, rerender} = render(<Button label="Click me" />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<button
color="white"
>
Click me
</button>
</DocumentFragment>
`);
// Update the label, but not the theme
rerender(<Button label="Click again" />);
// `computeStyle` should not be called again when Forget is enabled
expect(styleComputations).toBe(__FORGET__ ? 1 : 2);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<button
color="white"
>
Click again
</button>
</DocumentFragment>
`);
currentTheme = 'dark';
rerender(<Button label="Click again" />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<button
color="black"
>
Click again
</button>
</DocumentFragment>
`);
expect(styleComputations).toBe(__FORGET__ ? 2 : 3);
});

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import {render, screen, fireEvent} from '@testing-library/react';
import * as React from 'react';
import {expectLogsAndClear, log} from './expectLogs';
function Counter(props) {
let value = props.value;
let a = value++;
expect(a).toBe(props.value); // postfix
let b = ++value;
expect(b).toBe(props.value + 2); // previous postfix operation + prefix operation
let c = ++value;
expect(c).toBe(props.value + 3);
let d = value--;
expect(d).toBe(props.value + 3);
let e = --value;
expect(e).toBe(props.value + 1);
let f = --value;
expect(f).toBe(props.value);
expect(value).toBe(props.value);
return <span>{value}</span>;
}
test('use-state', async () => {
const {asFragment, rerender} = render(<Counter value={0} />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<span>
0
</span>
</DocumentFragment>
`);
rerender(<Counter value={1} />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<span>
1
</span>
</DocumentFragment>
`);
});

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
import {render, screen, fireEvent} from '@testing-library/react';
import * as React from 'react';
import {useState} from 'react';
import {expectLogsAndClear, log} from './expectLogs';
function Counter() {
let [state, setState] = useState(0);
return (
<div>
<Title text="Counter" />
<span>{state}</span>
<button data-testid="button" onClick={() => setState(state + 1)}>
increment
</button>
</div>
);
}
function Title({text}) {
log(`rendering: ${text}`);
return <h1>{text}</h1>;
}
test('use-state', async () => {
const {asFragment} = render(<Counter />);
expect(asFragment()).toMatchInlineSnapshot(`
<DocumentFragment>
<div>
<h1>
Counter
</h1>
<span>
0
</span>
<button
data-testid="button"
>
increment
</button>
</div>
</DocumentFragment>
`);
expectLogsAndClear(['rendering: Counter']);
fireEvent.click(screen.getByTestId('button'));
await screen.findByText('1');
expectLogsAndClear(__FORGET__ ? [] : ['rendering: Counter']);
});

import {makeObject_Primitives, mutate} from 'shared-runtime';
function Component() {
// a's mutable range should be the same as x's mutable range,
// since a is captured into x (which gets mutated later)
let a = makeObject_Primitives();
let x = [];
x.push(a);
mutate(x);
return [x, a];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component() {
// a's mutable range should be limited
// the following line
let a = someObj();
let x = [];
x.push(a);
return [x, a];
}

function component(a) {
let x = {a};
let y = {};
y.x = x['a'];
mutate(y);
return x;
}

function component() {
let z = [];
let y = {};
y.z = z;
let x = {};
x.y = y;
mutate(x.y.z);
return x;
}

function component() {
let z = [];
let y = {};
y.z = z;
let x = {};
x.y = y;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [],
isComponent: false,
};

function foo(cond) {
let a = {};
let b = {};
let c = {};
while (cond) {
let z = a;
a = b;
b = c;
c = z;
mutate(a, b);
}
a;
b;
c;
return a;
}
function mutate(x, y) {}

// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
import {identity, mutate, setProperty} from 'shared-runtime';
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDepNested(props) {
let x = {};
mutate(x);
let y = identity(identity(props.b) + 1);
setProperty(x, props.a);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: AllocatingPrimitiveAsDepNested,
params: [{a: 1, b: 2}],
sequentialRenders: [
// change b
{a: 1, b: 3},
// change b
{a: 1, b: 4},
// change a
{a: 2, b: 4},
// change a
{a: 3, b: 4},
],
};

// bar(props.b) is an allocating expression that produces a primitive, which means
// that Forget should memoize it.
// Correctness:
//   - y depends on either bar(props.b) or bar(props.b) + 1
function AllocatingPrimitiveAsDep(props) {
let y = foo(bar(props).b + 1);
return y;
}

// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useEffect, useState} from 'react';
let someGlobal = {};
function Component() {
const [state, setState] = useState(someGlobal);
const setGlobal = useCallback(() => {
someGlobal.value = true;
}, []);
useEffect(() => {
setGlobal();
}, []);
useEffect(() => {
setState(someGlobal.value);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useEffect, useState} from 'react';
let someGlobal = {};
function Component() {
const [state, setState] = useState(someGlobal);
const setGlobal = () => {
someGlobal.value = true;
};
useEffect(() => {
setGlobal();
}, []);
useEffect(() => {
setState(someGlobal.value);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useCallback, useEffect, useState} from 'react';
function Component() {
const callback = useCallback(() => {
window.foo = true;
}, []);
return <div>Ok</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useEffect, useState} from 'react';
let someGlobal = false;
function Component() {
const [state, setState] = useState(someGlobal);
const setGlobal = () => {
someGlobal = true;
};
useEffect(() => {
setGlobal();
}, []);
useEffect(() => {
setState(someGlobal);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useEffect, useState} from 'react';
let someGlobal = false;
function Component() {
const [state, setState] = useState(someGlobal);
useEffect(() => {
someGlobal = true;
}, []);
useEffect(() => {
setState(someGlobal);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useMemo} from 'react';
const someGlobal = {value: 0};
function Component({value}) {
const onClick = () => {
someGlobal.value = value;
};
return useMemo(() => {
return <div onClick={onClick}>{someGlobal.value}</div>;
}, []);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 0}],
sequentialRenders: [
{value: 1},
{value: 1},
{value: 42},
{value: 42},
{value: 0},
],
};

import {useEffect, useState} from 'react';
let someGlobal = {value: null};
function Component() {
const [state, setState] = useState(someGlobal);
// NOTE: if we initialize to eg null or a local, then it won't be a definitively global
// mutation below when we modify `y`. The point of this is example is that if all control
// flow paths produce a global, we allow the mutation in an effect
let x = someGlobal;
while (x == null) {
x = someGlobal;
}
// capture into a separate variable that is not a context variable.
const y = x;
useEffect(() => {
y.value = 'hello';
}, []);
useEffect(() => {
setState(someGlobal.value);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component(props) {
const ref = useRef(null);
return <Foo ref={ref} />;
}

function Component() {
const onClick = () => {
// Cannot assign to globals
someUnknownGlobal = true;
moduleLocal = true;
};
// It's possible that this could be an event handler / effect function,
// but we don't know that and optimistically assume it will only be
// called by an event handler or effect, where it is allowed to modify globals
return <div onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @validateRefAccessDuringRender @validateNoSetStateInRender:false
import {useCallback, useEffect, useRef, useState} from 'react';
function Component() {
const ref = useRef(null);
const [state, setState] = useState(false);
const setRef = useCallback(() => {
ref.current = 'Ok';
}, []);
useEffect(() => {
setRef();
}, []);
useEffect(() => {
setState(true);
}, []);
// We use state to force a re-render and observe whether the
// ref updated. This lets us check that the effect actually ran
// and wasn't DCE'd
return <Child key={String(state)} ref={ref} />;
}
function Child({ref}) {
// This violates the rules of React, so we access the ref in a child
// component
return ref.current;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @validateRefAccessDuringRender
import {useEffect, useRef, useState} from 'react';
function Component() {
const ref = useRef(null);
const [state, setState] = useState(false);
useEffect(() => {
ref.current = 'Ok';
}, []);
useEffect(() => {
setState(true);
}, []);
// We use state to force a re-render and observe whether the
// ref updated. This lets us check that the effect actually ran
// and wasn't DCE'd
return <Child key={String(state)} ref={ref} />;
}
function Child({ref}) {
// This violates the rules of React, so we access the ref in a child
// component
return ref.current;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @validateRefAccessDuringRender
import {useEffect, useRef, useState} from 'react';
function Component() {
const ref = useRef(null);
const [state, setState] = useState(false);
useEffect(() => {
const callback = () => {
ref.current = 'Ok';
};
}, []);
useEffect(() => {
setState(true);
}, []);
// We use state to force a re-render and observe whether the
// ref updated. This lets us check that the effect actually ran
// and wasn't DCE'd
return <Child key={String(state)} ref={ref} />;
}
function Child({ref}) {
// This violates the rules of React, so we access the ref in a child
// component
return ref.current;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component({a, b, c}) {
const x = [a];
const y = [null, b];
const z = [[], [], [c]];
x[0] = y[1];
z[0][0] = x[0];
return [x, z];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 1, b: 20, c: 300}],
sequentialRenders: [
{a: 2, b: 20, c: 300},
{a: 3, b: 20, c: 300},
{a: 3, b: 21, c: 300},
{a: 3, b: 22, c: 300},
{a: 3, b: 22, c: 301},
],
};

function Component(props) {
const x = foo(props.x);
const fn = function () {
const arr = [...bar(props)];
return arr.at(x);
};
const fnResult = fn();
return fnResult;
}

// arrayInstance.at should have the following effects:
//  - read on arg0
//  - read on receiver
//  - mutate on lvalue
function ArrayAtTest(props) {
const arr = [foo(props.x)];
const result = arr.at(bar(props.y));
return result;
}

// x's mutable range should extend to `mutate(y)`
function Component(props) {
let x = [42, {}];
const idx = foo(props.b);
let y = x.at(idx);
mutate(y);
return x;
}

function Component(props) {
const x = [0, ...props.foo, null, ...props.bar, 'z'];
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{foo: [1, 2, 3], bar: [4, 5, 6]}],
isComponent: false,
};

function Component(props) {
const x = [{}, [], props.value];
const y = x.join(() => 'this closure gets stringified, not called');
foo(y);
return [x, y];
}

function Component(props) {
// This item is part of the receiver, should be memoized
const item = {a: props.a};
const items = [item];
const mapped = items.map(item => item);
return mapped;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: {id: 42}}],
isComponent: false,
};

function Component(props) {
const x = [];
<dif>{x}</dif>;
const y = x.map(item => item);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const x = [];
<dif>{x}</dif>;
const y = x.map(item => item);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const x = [];
const y = x.map(item => {
item.updated = true;
return item;
});
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const x = [];
const y = x.map(item => {
item.updated = true;
return item;
});
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const x = [{}];
const y = x.map(item => {
return item;
});
y[0].flag = true;
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const f = item => item;
const x = [...props.items].map(f); // `f` doesn't escape here...
return [x, f]; // ...but it does here so it's memoized
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: [{id: 1}]}],
isComponent: false,
};

function component([a, b]) {
let y = {a};
let z = {b};
return [y, z];
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [['val1', 'val2']],
isComponent: false,
};

function Component(props) {
const a = [props.a, props.b, 'hello'];
const x = a.length;
const y = a.push;
return {a, x, y, z: a.concat};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: [1, 2], b: 2}],
isComponent: false,
};

function Component(props) {
const a = [props.a, props.b, 'hello'];
const x = a.push(42);
const y = a.at(props.c);
return {a, x, y};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 1, b: 2, c: 0}],
isComponent: false,
};

// arrayInstance.push should have the following effects:
//  - read on all args (rest parameter)
//  - mutate on receiver
function Component(props) {
const x = foo(props.x);
const y = {y: props.y};
const arr = [];
arr.push({});
arr.push(x, y);
return arr;
}

function Component() {
'use strict';
let [count, setCount] = React.useState(0);
const update = () => {
'worklet';
setCount(count => count + 1);
};
return <button onClick={update}>{count}</button>;
}

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export default ErrorView;

function useFoo() {
const update = () => {
'worklet';
return 1;
};
return update;
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [],
isComponent: false,
};

function Component(props) {
const x = [props.x];
const index = 0;
x[index] *= 2;
x['0'] += 3;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: 2}],
isComponent: false,
};

function g(props) {
const a = {b: {c: props.c}};
a.b.c = a.b.c + 1;
a.b.c *= 2;
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: g,
params: [{c: 2}],
isComponent: false,
};

function useBar(props) {
let z;
if (props.a) {
if (props.b) {
z = baz();
}
}
return z;
}

function foo() {
const a = [[1]];
const first = a.at(0);
first.set(0, 2);
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function g() {
const x = {y: {z: 1}};
x.y.z = x.y.z + 1;
x.y.z *= 2;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: g,
params: [],
isComponent: false,
};

function f() {
let x = 1;
x = x + 1;
x += 1;
x >>>= 1;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: [],
isComponent: false,
};

async function Component(props) {
const x = [];
await populateData(props.id, x);
return x;
}

async function Component(props) {
const user = await load(props.id);
return <div>{user.name}</div>;
}

import {useState, useMemo} from 'react';
function Component(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
function Component2(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}

import * as React from 'react';
import {useState, useMemo} from 'react';
function Component(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
function Component2(props) {
const [x] = useState(0);
const expensiveNumber = useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}

import * as React from 'react';
import {calculateExpensiveNumber} from 'shared-runtime';
function Component(props) {
const [x] = React.useState(0);
const expensiveNumber = React.useMemo(() => calculateExpensiveNumber(x), [x]);
return <div>{expensiveNumber}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

function useHook(a, b) {
switch (a) {
case 1:
if (b == null) {
return;
}
console.log(b);
break;
case 2:
return;
default:
return;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: useHook,
params: [1, 'foo'],
};

import {useMemo} from 'react';
function Component(props) {
const outerHandlers = useMemo(() => {
let handlers = {value: props.value};
switch (props.test) {
case true: {
console.log(handlers.value);
break;
}
default: {
}
}
return handlers;
});
return outerHandlers;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{test: true, value: 'hello'}],
};

function Component(props) {
const maybeMutable = new MaybeMutable();
return <div>{maybeMutate(maybeMutable)}</div>;
}

function Component(props) {
let x = makeObject();
x.foo((x = makeObject()));
return x;
}

function Component(props) {
let x = makeObject();
x.foo(([x] = makeObject()));
return x;
}

function Component(props) {
const x = foo(...props.a, null, ...props.b);
return x;
}

function Component(props) {
const x = makeFunction(props);
const y = x(
<div>
<span>{props.text}</span>
</div>
);
return y;
}

function foo() {}
function Component(props) {
const a = [];
const b = {};
foo(a, b);
let _ = <div a={a} />;
foo(b);
return <div a={a} b={b} />;
}

// @validateNoCapitalizedCalls @hookPattern:".*\b(use[^$]+)$"
import * as React from 'react';
const React$useState = React.useState;
const THIS_IS_A_CONSTANT = () => {};
function Component() {
const b = Boolean(true); // OK
const n = Number(3); // OK
const s = String('foo'); // OK
const [state, setState] = React$useState(0); // OK
const [state2, setState2] = React.useState(1); // OK
const constant = THIS_IS_A_CONSTANT(); // OK
return 3;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: true,
};

function component(a) {
let x = {a};
(function () {
let q = x;
(function () {
q.b = 1;
})();
})();
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [2],
};

function component(a) {
let x = {a};
const f0 = function () {
let q = x;
const f1 = function () {
q.b = 1;
};
f1();
};
f0();
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function getNativeLogFunction(level) {
return function () {
let str;
if (arguments.length === 1 && typeof arguments[0] === 'string') {
str = arguments[0];
} else {
str = Array.prototype.map
.call(arguments, function (arg) {
return inspect(arg, {
depth: 10,
});
})
.join(', ');
}
const firstArg = arguments[0];
let logLevel = level;
if (
typeof firstArg === 'string' &&
firstArg.slice(0, 9) === 'Warning: ' &&
logLevel >= LOG_LEVELS.error
) {
logLevel = LOG_LEVELS.warn;
}
if (global.__inspectorLog) {
global.__inspectorLog(
INSPECTOR_LEVELS[logLevel],
str,
[].slice.call(arguments),
INSPECTOR_FRAMES_TO_SKIP
);
}
if (groupStack.length) {
str = groupFormat('', str);
}
global.nativeLoggingHook(str, logLevel);
};
}

function component(a) {
let z = {a};
(function () {
(function () {
z.b = 1;
})();
})();
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [2],
};

function component(a) {
let z = {a};
const f0 = function () {
const f1 = function () {
z.b = 1;
};
f1();
};
f0();
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a};
let x = () => {
console.log(z);
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {mutate} from 'shared-runtime';
function component(foo, bar) {
let x = {foo};
let y = {bar};
(function () {
let a = {y};
let b = x;
a.x = b;
})();
mutate(y);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo', 'bar'],
};

function component(foo, bar) {
let x = {foo};
let y = {bar};
const f0 = function () {
let a = {y};
let b = x;
a.x = b;
};
f0();
mutate(y);
return x;
}

const {mutate} = require('shared-runtime');
function component(foo, bar) {
let x = {foo};
let y = {bar};
(function () {
let a = [y];
let b = x;
a.x = b;
})();
mutate(y);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo', 'bar'],
};

function component(foo, bar) {
let x = {foo};
let y = {bar};
const f0 = function () {
let a = [y];
let b = x;
a.x = b;
};
f0();
mutate(y);
return x;
}

const {mutate} = require('shared-runtime');
function component(foo, bar) {
let x = {foo};
let y = {bar};
(function () {
let a = [y];
let b = x;
a.x = b;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo', 'bar'],
};

function component(foo, bar) {
let x = {foo};
let y = {bar};
const f0 = function () {
let a = [y];
let b = x;
a.x = b;
};
f0();
mutate(y);
return y;
}

const {mutate} = require('shared-runtime');
function component(foo, bar) {
let x = {foo};
let y = {bar};
(function () {
let a = {y};
let b = x;
a.x = b;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo', 'bar'],
};

function component(foo, bar) {
let x = {foo};
let y = {bar};
const f0 = function () {
let a = {y};
let b = x;
a.x = b;
};
f0();
mutate(y);
return y;
}

const {mutate} = require('shared-runtime');
function component(a) {
let x = {a};
let y = {};
(function () {
y['x'] = x;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo'],
};

function component(a) {
let x = {a};
let y = {};
const f0 = function () {
y['x'] = x;
};
f0();
mutate(y);
return y;
}

const {mutate} = require('shared-runtime');
function component(a) {
let x = {a};
let y = {};
(function () {
y.x = x;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo'],
};

function component(a) {
let x = {a};
let y = {};
const f0 = function () {
y.x = x;
};
f0();
mutate(y);
return y;
}

import {mutate} from 'shared-runtime';
function component(a) {
let x = {a};
let y = {};
(function () {
let a = y;
a['x'] = x;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo'],
};

function component(a) {
let x = {a};
let y = {};
const f0 = function () {
let a = y;
a['x'] = x;
};
f0();
mutate(y);
return y;
}

const {mutate} = require('shared-runtime');
function component(a) {
let x = {a};
let y = {};
(function () {
let a = y;
a.x = x;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo'],
};

function component(a) {
let x = {a};
let y = {};
const f0 = function () {
let a = y;
a.x = x;
};
f0();
mutate(y);
return y;
}

function component(a, b) {
let y = {b};
let z = {a};
let x = function () {
z.a = 2;
y.b;
};
x();
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [{a: 'val1', b: 'val2'}],
isComponent: false,
};

function component(a, b) {
let y = {b};
let z = {a};
let x = function () {
z.a = 2;
y.b;
};
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let y = {b: {a}};
let x = function () {
y.b.a = 2;
};
x();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a, b) {
let z = {a};
let y = {b};
let x = function () {
z.a = 2;
console.log(y.b);
};
x();
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

const {mutate} = require('shared-runtime');
function component(a) {
let x = {a};
let y = {};
(function () {
y = x;
})();
mutate(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['foo'],
};

function component(a) {
let x = {a};
let y = {};
const f0 = function () {
y = x;
};
f0();
mutate(y);
return y;
}

function component(a) {
let z = {a};
let x = function () {
console.log(z);
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0][1];
})();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [['val1', 'val2']],
isComponent: false,
};

function bar(a) {
let x = [a];
let y = {};
const f0 = function () {
y = x[0][1];
};
f0();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [['val1', 'val2']],
isComponent: false,
};

function bar(a, b) {
let x = [a, b];
let y = {};
let t = {};
(function () {
y = x[0][1];
t = x[1][0];
})();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [
[1, 2],
[2, 3],
],
};

function bar(a, b) {
let x = [a, b];
let y = {};
let t = {};
const f0 = function () {
y = x[0][1];
t = x[1][0];
};
f0();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [
[1, 2],
[2, 3],
],
};

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0].a[1];
})();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [{a: ['val1', 'val2']}],
isComponent: false,
};

function bar(a) {
let x = [a];
let y = {};
const f0 = function () {
y = x[0].a[1];
};
f0();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: [{a: ['val1', 'val2']}],
isComponent: false,
};

function bar(a) {
let x = [a];
let y = {};
(function () {
y = x[0];
})();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: ['TodoAdd'],
};

function bar(a) {
let x = [a];
let y = {};
const f0 = function () {
y = x[0];
};
f0();
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: bar,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a, b) {
let z = {a};
(function () {
mutate(z);
})();
let y = z;
{
// z is shadowed & renamed but the lambda is unaffected.
let z = {b};
y = {y, z};
}
return y;
}

// @debug
function component(a, b) {
let z = {a};
let y = b;
let x = function () {
if (y) {
// we don't know for sure this mutates, so we should assume
// that there is no mutation so long as `x` isn't called
// during render
maybeMutate(z);
}
};
return x;
}

function component(a) {
let t = {a};
function x() {
t.foo();
}
x(t);
return t;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Foo(props) {
const onFoo = useCallback(
reason => {
log(props.router.location);
},
[props.router.location]
);
return onFoo;
}

function component({mutator}) {
const poke = () => {
mutator.poke();
};
const hide = () => {
mutator.user.hide();
};
return <Foo poke={poke} hide={hide}></Foo>;
}

function component(a, b) {
let z = {a};
{
let z = {b};
(function () {
mutate(z);
})();
}
return z;
}

function component(a, b) {
let z = {a};
let p = () => <Foo>{z}</Foo>;
return p();
}

function component(a) {
let z = {a};
let x = function () {
let z;
mutate(z);
};
return x;
}

function StoreLandingUnseenGiftModalContainer(a) {
const giftsSeen = {a};
return (gift => (gift.id ? giftsSeen[gift.id] : false))();
}
export const FIXTURE_ENTRYPOINT = {
fn: StoreLandingUnseenGiftModalContainer,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a};
let x;
{
x = function () {
console.log(z);
};
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a};
let x = function () {
console.log(z.a);
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a: {a}};
let x = function () {
z.a.a();
};
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a: {a}};
let x = function () {
(function () {
console.log(z.a.a);
})();
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a: {a}};
let x = function () {
console.log(z.a.a);
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let x = {a};
let y = 1;
(function () {
y = x;
})();
mutate(y);
return y;
}

function component(a) {
let z = {a};
let x = function () {
{
console.log(z);
}
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(a) {
let z = {a};
let x = function () {
(function () {
console.log(z);
})();
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {makeArray} from 'shared-runtime';
function Component() {
let x,
y = (x = {});
const foo = () => {
x = makeArray();
};
foo();
return [y, x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function foo() {
const x = {x: 0};
const y = {z: 0};
const z = {z: 0};
x.x += y.y *= 1;
z.z += y.y *= x.x &= 3;
return z;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

// @enableChangeDetectionForDebugging
function Component(props) {
let x = null;
if (props.cond) {
x = [];
x.push(props.value);
}
return x;
}

// @compilationMode(infer)
class Component {
_renderMessage = () => {
const Message = () => {
const message = this.state.message;
return <div>{message}</div>;
};
return <Message />;
};
render() {
return this._renderMessage();
}
}

// @enableEmitFreeze @instrumentForget
function useFoo(props) {
return foo(props.x);
}

// @enableEmitFreeze true
function MyComponentName(props) {
let x = {};
foo(x, props.a);
foo(x, props.b);
let y = [];
y.push(x);
return y;
}

// @instrumentForget @compilationMode(annotation) @gating
function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

// @instrumentForget @compilationMode(annotation)
function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

function foo(a, b, c) {
label: if (a) {
while (b) {
if (c) {
break label;
}
}
}
return c;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @flow @compilationMode(infer)
export default component Foo(bar: number) {
return <Bar bar={bar} />;
}
component Bar(bar: number) {
return <div>{bar}</div>;
}
function shouldNotCompile() {}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{bar: 42}],
};

function Component(props) {
const items = props.items;
const maxItems = props.maxItems;
const renderedItems = [];
const seen = new Set();
const max = Math.max(0, maxItems);
for (let i = 0; i < items.length; i += 1) {
const item = items.at(i);
if (item == null || seen.has(item)) {
continue;
}
seen.add(item);
renderedItems.push(<div>{item}</div>);
if (renderedItems.length >= max) {
break;
}
}
const count = renderedItems.length;
return (
<div>
<h1>{count} Items</h1>
{renderedItems}
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// Should print A, B, arg, original
function Component() {
const changeF = o => {
o.f = () => console.log('new');
};
const x = {
f: () => console.log('original'),
};
(console.log('A'), x)[(console.log('B'), 'f')](
(changeF(x), console.log('arg'), 1)
);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component(props) {
const x = foo[props.method](...props.a, null, ...props.b);
return x;
}

function Component(props) {
let a = foo();
// freeze `a` so we know the next line cannot mutate it
<div>{a}</div>;
// b should be dependent on `props.a`
let b = bar(a[props.a] + 1);
return b;
}

function component(a, b) {
let y = {a};
let x = {b};
x['y'] = y;
mutate(x);
return x;
}

function component() {
let [x, setX] = useState(0);
const handler = v => setX(v);
return <Foo handler={handler}></Foo>;
}

/**
* props.b *does* influence `a`
*/
function Component(props) {
const a = [];
a.push(props.a);
label: {
if (props.b) {
break label;
}
a.push(props.c);
}
a.push(props.d);
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

/**
* props.b does *not* influence `a`
*/
function ComponentA(props) {
const a_DEBUG = [];
a_DEBUG.push(props.a);
if (props.b) {
return null;
}
a_DEBUG.push(props.d);
return a_DEBUG;
}
/**
* props.b *does* influence `a`
*/
function ComponentB(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
}
a.push(props.d);
return a;
}
/**
* props.b *does* influence `a`, but only in a way that is never observable
*/
function ComponentC(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
return null;
}
a.push(props.d);
return a;
}
/**
* props.b *does* influence `a`
*/
function ComponentD(props) {
const a = [];
a.push(props.a);
if (props.b) {
a.push(props.c);
return a;
}
a.push(props.d);
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: ComponentA,
params: [{a: 1, b: false, d: 3}],
};

function ComponentA(props) {
const a = [];
const b = [];
if (b) {
a.push(props.p0);
}
if (props.p1) {
b.push(props.p2);
}
return <Foo a={a} b={b} />;
}
function ComponentB(props) {
const a = [];
const b = [];
if (mayMutate(b)) {
a.push(props.p0);
}
if (props.p1) {
b.push(props.p2);
}
return <Foo a={a} b={b} />;
}
function Foo() {}
function mayMutate() {}

function Component(props) {
const [x, setX] = useState(0);
const foo = () => {
setX(1);
};
if (props.cond) {
setX(2);
foo();
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {identity} from 'shared-runtime';
function Component(props) {
const $ = identity('jQuery');
const t0 = identity([$]);
return t0;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {shallowCopy} from 'shared-runtime';
function Component(props) {
const x = shallowCopy(props);
// These calls should view x as readonly and be grouped outside of the reactive scope for x:
console.log(x);
console.info(x);
console.warn(x);
console.error(x);
console.trace(x);
console.table(x);
global.console.log(x);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 1, b: 2}],
isComponent: false,
};

function foo() {
const isX = GLOBAL_IS_X;
const getJSX = () => {
return <Child x={isX}></Child>;
};
const result = getJSX();
return result;
}

function foo() {
const x = 42;
const f = () => {
console.log(x);
};
f();
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function Component(props) {
const index = 'foo';
const x = {};
x[index] = x[index] + x['bar'];
x[index](props.foo);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {identity} from 'shared-runtime';
// repro for context identifier scoping bug, in which x was
// inferred as a context variable.
function Component() {
let x = 2;
const obj = {
method() {},
};
x = 4;
identity(obj);
// constant propagation should return 4 here
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {invoke} from 'shared-runtime';
function Component() {
let x = 2;
const fn = () => {
return {x: 'value'};
};
invoke(fn);
x = 3;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {identity} from 'shared-runtime';
function Foo() {
const CONSTANT = 1;
const x = {
foo() {
return identity(CONSTANT);
},
};
return x.foo();
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

import {CONST_STRING0, Text} from 'shared-runtime';
function useFoo() {
'use no forget';
return {tab: CONST_STRING0};
}
function Test() {
const {tab} = useFoo();
const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING0;
return <Text value={currentTab} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Test,
params: [],
isComponent: true,
};

import {CONST_STRING0, CONST_STRING1, Text} from 'shared-runtime';
function useFoo() {
'use no forget';
return {tab: CONST_STRING1};
}
function Test() {
const {tab} = useFoo();
const currentTab = tab === CONST_STRING0 ? CONST_STRING0 : CONST_STRING1;
return <Text value={currentTab} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Test,
params: [],
isComponent: true,
};

import {Stringify} from 'shared-runtime';
function foo() {
return (
<Stringify
value={[
123.45 | 0,
123.45 & 0,
123.45 ^ 0,
123 << 0,
123 >> 0,
123 >>> 0,
123.45 | 1,
123.45 & 1,
123.45 ^ 1,
123 << 1,
123 >> 1,
123 >>> 1,
3 ** 2,
3 ** 2.5,
3.5 ** 2,
2 ** (3 ** 0.5),
4 % 2,
4 % 2.5,
4 % 3,
4.5 % 2,
]}
/>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function foo() {
let y = 0;
for (const x = 100; x < 10; x) {
y = y + 1;
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function Component(props) {
const x = 42;
const onEvent = () => {
console.log(x);
};
return <Foo onEvent={onEvent} />;
}

function foo(a, b, c) {
let x;
if (a) {
x = 2 - 1;
} else {
x = 0 + 1;
}
if (x === 1) {
return b;
} else {
return c;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo() {
const a = 'a' + 'b';
const c = 'c';
return a + c;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

import {Stringify} from 'shared-runtime';
function foo() {
let _b;
const b = true;
if (!b) {
_b = 'bar';
} else {
_b = 'baz';
}
return (
<Stringify
value={{
_b,
b0: !true,
n0: !0,
n1: !1,
n2: !2,
n3: !-1,
s0: !'',
s1: !'a',
s2: !'ab',
u: !undefined,
n: !null,
}}
/>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function foo() {
let x = 100;
let y = 0;
while (x < 10) {
y += 1;
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function foo() {
const a = 1;
const b = 2;
const c = 3;
const d = a + b;
const e = d * c;
const f = e / d;
const g = f - e;
if (g) {
console.log('foo');
}
const h = g;
const i = h;
const j = i;
return j;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function Foo() {}
function Component(props) {
const a = [];
const b = {};
new Foo(a, b);
let _ = <div a={a} />;
new Foo(b);
return <div a={a} b={b} />;
}

import {useMemo} from 'react';
import {Stringify} from 'shared-runtime';
function Component(props) {
let Component = Stringify;
Component = useMemo(() => {
return Component;
});
return <Component {...props} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{name: 'Sathya'}],
};

import {invoke} from 'shared-runtime';
function Component({shouldReassign}) {
let x = null;
const reassign = () => {
if (shouldReassign) {
x = 2;
}
};
invoke(reassign);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{shouldReassign: true}],
sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],
};

import {conditionalInvoke} from 'shared-runtime';
// same as context-variable-reactive-explicit-control-flow.js, but make
// the control flow implicit
function Component({shouldReassign}) {
let x = null;
const reassign = () => {
x = 2;
};
conditionalInvoke(shouldReassign, reassign);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{shouldReassign: true}],
sequentialRenders: [{shouldReassign: false}, {shouldReassign: true}],
};

import {invoke} from 'shared-runtime';
function Component({cond}) {
let x = 2;
const obj = {
method(cond) {
if (cond) {
x = 4;
}
},
};
invoke(obj.method, cond);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

import {Stringify} from 'shared-runtime';
function Component(props) {
let x = null;
const callback = () => {
console.log(x);
};
x = {};
return <Stringify callback={callback} shouldInvokeFns={true} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {invoke} from 'shared-runtime';
function Component({value}) {
let x = null;
const reassign = () => {
x = value;
};
invoke(reassign);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 2}],
sequentialRenders: [{value: 2}, {value: 4}],
};

import {conditionalInvoke} from 'shared-runtime';
function Component({doReassign1, doReassign2}) {
let x = {};
const reassign1 = () => {
x = 2;
};
const reassign2 = () => {
x = 3;
};
conditionalInvoke(doReassign1, reassign1);
conditionalInvoke(doReassign2, reassign2);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{doReassign1: true, doReassign2: true}],
sequentialRenders: [
{doReassign1: true, doReassign2: true},
{doReassign1: true, doReassign2: false},
{doReassign1: false, doReassign2: false},
],
};

import {useState} from 'react';
function component() {
let [x, setX] = useState(0);
const handler = event => setX(event.target.value);
return <input onChange={handler} value={x} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [],
isComponent: true,
};

import React from 'react';
import {shallowCopy} from 'shared-runtime';
function Component(props) {
const childProps = {style: {width: props.width}};
const element = React.createElement('div', childProps, ['hello world']);
shallowCopy(childProps); // function that in theory could mutate, we assume not bc createElement freezes
return element;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function foo(props) {
let x = 0;
let y = 0;
while (y < props.max) {
x++;
y++;
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{max: 10}],
isComponent: false,
};

function Component(props) {
const _ = 42;
return props.value;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

function Component(props) {
let i = 0;
i++;
i = props.i;
return i;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{i: 42}],
};

function Component(props) {
let i = 0;
--i;
i = props.i;
return i;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{i: 42}],
};

function Component(props) {
const x = [];
debugger;
x.push(props.value);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
debugger;
if (props.cond) {
debugger;
} else {
while (props.cond) {
debugger;
}
}
debugger;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(p) {
let x;
const foo = () => {
x = {};
};
foo();
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Foo() {
return (function t() {
let x = {};
let y = {};
return function a(x = () => {}) {
return (function b(y = []) {
return [x, y];
})();
};
})();
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

function Component(x = [-1, 1]) {
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

import {identity} from 'shared-runtime';
function Component(x = identity([() => {}, true, 42, 'hello'])) {
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

function Component(x = () => {}) {
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

function Component(x = () => [-1, true, 42.0, 'hello']) {
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

function Component(props) {
const x = {a: props.a, b: props.b};
const key = 'b';
delete x[key];
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const x = {a: props.a, b: props.b};
delete x.b;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b) {
const x = [];
x.push(a);
<div>{x}</div>;
const y = [];
if (x.length) {
y.push(x);
}
if (b) {
y.push(b);
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(x, y, z) {
const items = [z];
items.push(x);
const items2 = [];
if (x) {
items2.push(y);
}
if (y) {
items.push(x);
}
return items2;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {identity} from 'shared-runtime';
function Component(props) {
let x;
[x] = props.value;
const foo = () => {
x = identity(props.value[0]);
};
foo();
return {x};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: [42]}],
};

import {identity} from 'shared-runtime';
function Component(props) {
let [x] = props.value;
const foo = () => {
x = identity(props.value[0]);
};
foo();
return <div>{x}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: [42]}],
};

let someGlobal = {};
function component(a) {
let x = {a, someGlobal};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['value 1'],
isComponent: false,
};

function Component(props) {
const [x = [-1, 1]] = props.value;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: []}],
};

function foo(props) {
let x, y;
({x, y} = {x: props.a, y: props.b});
console.log(x); // prevent DCE from eliminating `x` altogether
x = props.c;
return x + y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo() {
const {'data-foo-bar': x, a: y, data: z} = {'data-foo-bar': 1, a: 2, data: 3};
return [x, y, z];
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

import {identity} from 'shared-runtime';
function Component(props) {
let x;
({x} = props);
const foo = () => {
x = identity(props.x);
};
foo();
return {x};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: 42}],
};

import {identity} from 'shared-runtime';
function Component(props) {
let {x} = props;
const foo = () => {
x = identity(props.x);
};
foo();
return {x};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: 42}],
};

function foo({'data-foo-bar': dataTestID}) {
return dataTestID;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{'data-foo-bar': {}}],
isComponent: false,
};

function foo({data: dataTestID}) {
return dataTestID;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{data: {}}],
isComponent: false,
};

function foo() {
const {'data-foo-bar': t} = {'data-foo-bar': 1};
return t;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function foo() {
const {data: t} = {data: 1};
return t;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function Component(props) {
const [[x] = ['default']] = props.y;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component([a = 2]) {
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x;
if (props.cond) {
[[x] = ['default']] = props.y;
} else {
x = props.fallback;
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
let d, g, n, o;
[
d,
[
{
e: {f: g},
},
],
] = a;
({
l: {
m: [[n]],
},
o,
} = b);
return {d, g, n, o};
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
// destructure slot index has a hole in the input, should return default
const [x = 42] = props.value;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: [, /* hole! */ 3.14]}],
};

function Component(props) {
// destructure slot index has an explicit null in the input, should return null (not the default)
const [x = 42] = props.value;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: [null]}],
};

function Component(props) {
// destructure slot index has an explicit undefined in the input, should return default
const [x = 42] = props.value;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: [undefined]}],
};

function Component(props) {
// destructure past end of empty array, should evaluate to default
const [x = 42] = props.value;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: []}],
};

import {Stringify, graphql} from 'shared-runtime';
function useFragment(_arg1, _arg2) {
'use no forget';
return {
urls: ['url1', 'url2', 'url3'],
comments: ['comment1'],
};
}
function Component(props) {
const post = useFragment(
graphql`
fragment F on T {
id
}
`,
props.post
);
const allUrls = [];
// `media` and `urls` are exported from the scope that will wrap this code,
// but `comments` is not (it doesn't need to be memoized, bc the callback
// only checks `comments.length`)
// because of the scope, the let declaration for media and urls are lifted
// out of the scope, and the destructure statement ends up turning into
// a reassignment, instead of a const declaration. this means we try to
// reassign `comments` when there's no declaration for it.
const {media = null, comments = [], urls = []} = post;
const onClick = e => {
if (!comments.length) {
return;
}
console.log(comments.length);
};
allUrls.push(...urls);
return <Stringify media={media} allUrls={allUrls} onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{post: {}}],
isComponent: true,
};

import {useFragment} from 'shared-runtime';
function Component(props) {
const post = useFragment(
graphql`
fragment F on T {
id
}
`,
props.post
);
const allUrls = [];
// `media` and `urls` are exported from the scope that will wrap this code,
// but `comments` is not (it doesn't need to be memoized, bc the callback
// only checks `comments.length`)
// because of the scope, the let declaration for media and urls are lifted
// out of the scope, and the destructure statement ends up turning into
// a reassignment, instead of a const declaration. this means we try to
// reassign `comments` when there's no declaration for it.
const {media, comments, urls} = post;
const onClick = e => {
if (!comments.length) {
return;
}
console.log(comments.length);
};
allUrls.push(...urls);
return <Media media={media} onClick={onClick} />;
}

function Component(props) {
const {x: {y} = {y: 'default'}} = props.y;
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component({a = 2}) {
return a;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const [y, ...{z}] = props.value;
return [y, z];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: ['y', {z: 'z!'}]}],
};

function Component(props) {
const x = [];
x.push(props.value);
const {length: y} = x;
foo(y);
return [x, y];
}

import {identity} from 'shared-runtime';
function Component(props) {
const {
x: {destructured},
sameName: renamed,
} = props;
const sameName = identity(destructured);
return [sameName, renamed];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: {destructured: 0}, sameName: 2}],
};

function Component(props) {
const [x = true ? 1 : 0] = props.y;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{y: []}],
};

// @flow
function Component(props) {
const [x = ([]: Array<number>)] = props.y;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{y: []}],
};

function foo(a, b, c) {
const [
d,
[
{
e: {f},
...g
},
],
...h
] = a;
const {
l: {
m: [[n], ...o],
},
p,
} = b;
return [d, f, g, h, n, o, p];
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
do {
break;
} while (props.cond);
return props;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x = [1, 2, 3];
let ret = [];
do {
let item = x.pop();
ret.push(item * 2);
} while (x.length && props.cond);
return ret;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x = [0, 1, 2, 3];
do {
if (x === 0) {
break;
}
mutate(x);
} while (props.cond);
return x;
}

function Component() {
const x = [0, 1, 2, 3];
const ret = [];
do {
const item = x.pop();
if (item === 0) {
continue;
}
ret.push(item / 2);
} while (x.length);
return ret;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component(props) {
let x = [1, 2, 3];
do {
mutate(x);
break;
} while (props.cond);
return x;
}

function Component() {
let x = [1, 2, 3];
let ret = [];
do {
let item = x.pop();
ret.push(item * 2);
} while (x.length);
return ret;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component(props) {
let x = 0;
label: if (props.a) {
x = 1;
} else {
if (props.b) {
x = 2;
} else {
break label;
}
x = 3;
}
label2: switch (props.c) {
case 'a': {
x = 4;
break;
}
case 'b': {
break label2;
}
case 'c': {
x = 5;
// intentional fallthrough
}
default: {
x = 6;
}
}
if (props.d) {
return null;
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {ValidateMemoization} from 'shared-runtime';
// Achieving Forget's level of memoization precision in this example isn't possible with useMemo
// without significantly altering the code, so disable the non-Forget evaluation of this fixture.
// @disableNonForgetInSprout
function Component({a, b, c}) {
const x = [];
let y;
if (a) {
y = [b];
}
x.push(c);
// this scope should not merge with the above scope because y does not invalidate
// on changes to `c`
const z = [y];
// return [x, z];
return (
<>
<ValidateMemoization inputs={[a, b, c]} output={x} />
<ValidateMemoization inputs={[a, b]} output={z} />
</>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: false, b: null, c: 0}],
sequentialRenders: [
{a: false, b: null, c: 0},
{a: false, b: null, c: 1},
{a: true, b: 0, c: 1},
{a: true, b: 1, c: 1},
],
};

import {Stringify, makeObject_Primitives} from 'shared-runtime';
function Component(props) {
const array = [props.count];
const x = makeObject_Primitives();
const element = <div>{array}</div>;
console.log(x);
return <div>{element}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{count: 42}],
};

import {Stringify} from 'shared-runtime';
function Component(props) {
let x;
const array = [props.count];
x = array;
const element = <div>{array}</div>;
return (
<div>
{element}
{x}
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{count: 42}],
};

import * as React from 'react';
function Component(props) {
const onClick = React.useCallback(() => {
console.log(props.value);
}, [props.value]);
return <div onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import * as React from 'react';
function Component(props) {
const x = React.useMemo(() => {
const x = [];
x.push(props.value);
return x;
}, [props.value]);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

function Component(props) {
let x = [];
if (props.cond) {
x.push(props.a);
if (props.b) {
const y = [props.b];
x.push(y);
// oops no memo!
return x;
}
// oops no memo!
return x;
} else {
return foo();
}
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true, a: 42, b: 3.14}],
};

import {makeArray} from 'shared-runtime';
/**
* This fixture tests what happens when a reactive has no declarations (other than an early return),
* no reassignments, and no dependencies. In this case the only thing we can use to decide if we
* should take the if or else branch is the early return declaration. But if that uses the same
* sentinel as the memo cache sentinel, then if the previous execution did not early return it will
* look like we didn't execute the memo block yet, and we'll needlessly re-execute instead of skipping
* to the else branch.
*
* We have to use a distinct sentinel for the early return value.
*
* Here the fixture will always take the "else" branch and never early return. Logging (not included)
* confirms that the scope for `x` only executes once, on the first render of the component.
*/
let ENABLE_FEATURE = false;
function Component(props) {
let x = [];
if (ENABLE_FEATURE) {
x.push(42);
return x;
} else {
console.log('fallthrough');
}
return makeArray(props.a);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{a: 42},
{a: 42},
{a: 3.14},
{a: 3.14},
{a: 42},
{a: 3.14},
{a: 42},
{a: 3.14},
],
};

import {makeArray} from 'shared-runtime';
function Component(props) {
let x = [];
if (props.cond) {
x.push(props.a);
// oops no memo!
return x;
} else {
return makeArray(props.b);
}
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
// pattern 1
{cond: true, a: 42},
{cond: true, a: 42},
// pattern 2
{cond: false, b: 3.14},
{cond: false, b: 3.14},
// pattern 1
{cond: true, a: 42},
// pattern 2
{cond: false, b: 3.14},
// pattern 1
{cond: true, a: 42},
// pattern 2
{cond: false, b: 3.14},
],
};

function MyApp(props) {
let res;
if (props.cond) {
return;
} else {
res = 1;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: MyApp,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component() {
const Foo = () => {
someGlobal = true;
};
return <Foo />;
}

function Component() {
const foo = () => {
someGlobal = true;
};
// Children are generally access/called during render, so
// modifying a global in a children function is almost
// certainly a mistake.
return <Foo>{foo}</Foo>;
}

function Component() {
const foo = () => {
someGlobal = true;
};
return <div {...foo} />;
}

// @enableFlowSuppressions
function Foo(props) {
// $FlowFixMe[react-rule-hook]
useX();
return null;
}

// @eslintSuppressionRules(my-app/react-rule)
/* eslint-disable my-app/react-rule */
function lowercasecomponent() {
'use forget';
const x = [];
// eslint-disable-next-line my-app/react-rule
return <div>{x}</div>;
}
/* eslint-enable my-app/react-rule */

function Component(props) {
let x = makeObject();
x.foo(([[x]] = makeObject()));
return x;
}

// @validateNoCapitalizedCalls
function Foo() {
let x = Bar;
x(); // ERROR
}

// @validateNoCapitalizedCalls
function Component() {
const x = SomeFunc();
return x;
}

// @validateNoCapitalizedCalls
function Component() {
const x = someGlobal.SomeFunc();
return x;
}

// @enableEmitFreeze @instrumentForget
let makeReadOnly = 'conflicting identifier';
function useFoo(props) {
return foo(props.x);
}

// @flow @gating
component Foo(ref: React.RefSetter<Controls>) {
return <Bar ref={ref} />;
}

function Component(props) {
let x = null;
if (props.cond) {
x = React.useNonexistentHook();
}
return x;
}

function Component(props) {
let x = null;
if (props.cond) {
x = Foo.useFoo();
}
return x;
}

import {identity, invoke} from 'shared-runtime';
function foo() {
let x = 2;
const fn1 = () => {
const copy1 = (x = 3);
return identity(copy1);
};
const fn2 = () => {
const copy2 = (x = 4);
return [invoke(fn1), copy2, identity(copy2)];
};
return invoke(fn2);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
};

function Component() {
let x = null;
function foo() {
x = 9;
}
const y = bar(foo);
return <Child y={y} />;
}

function Component(
x,
y = () => {
return x;
}
) {
return y();
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

import {identity} from 'shared-runtime';
function useInvalid() {
const x = identity(x);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: useInvalid,
params: [],
};

function Component() {
let callback = () => {
callback = null;
};
return <div onClick={callback} />;
}

// @gating
const Foo = React.forwardRef(Foo_withRef);
function Foo_withRef(props, ref) {
return <Bar ref={ref} {...props}></Bar>;
}

// @gating
import {memo} from 'react';
export default memo(Foo);
function Foo() {}

function component(a) {
let t = {a};
x(t); // hoisted call
function x(p) {
p.foo();
}
return t;
}

function hoisting() {
function bar() {
return x;
}
return baz(); // OK: FuncDecls are HoistableDeclarations that have both declaration and value hoisting
function baz() {
return bar();
}
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function useFoo() {}
useFoo.useBar = function () {
return 'foo';
};
function Foo() {
let bar = useFoo.useBar;
return bar();
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
const value = ref.current;
return value;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
const renderItem = item => {
const aliasedRef = ref;
const current = aliasedRef.current;
return <Foo item={item} current={current} />;
};
return <Items>{props.items.map(item => renderItem(item))}</Items>;
}

function Component(props) {
const x = [];
<div>{x}</div>;
x.push(props.value);
return x;
}

function Component(props) {
const x = useState;
const state = x(null);
return state[0];
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
x[0] = true;
return x;
}

import {useFragment as readFragment} from 'shared-runtime';
function Component(props) {
let data;
if (props.cond) {
data = readFragment();
}
return data;
}

import {useState as state} from 'react';
function Component(props) {
let s;
if (props.cond) {
[s] = state();
}
return s;
}

import {makeArray as useArray} from 'other';
function Component(props) {
let data;
if (props.cond) {
data = useArray();
}
return data;
}

function Component({item, cond}) {
const [prevItem, setPrevItem] = useState(item);
const [state, setState] = useState(0);
useMemo(() => {
if (cond) {
setPrevItem(item);
setState(0);
}
}, [cond, key, init]);
return state;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
delete x[y];
return x;
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
delete x.y;
return x;
}

function useFoo(props) {
[x] = props;
return {x};
}

function Component(props) {
let a;
[a, b] = props.value;
return [a, b];
}

// @validateRefAccessDuringRender
function Component() {
const ref = useRef(null);
ref.current = false;
return <button ref={ref} />;
}

// @validateRefAccessDuringRender
function Component() {
const ref = useRef(null);
const setRef = () => {
ref.current = false;
};
const changeRef = setRef;
changeRef();
return <button ref={ref} />;
}

function Component(props) {
const [x, setX] = useState({value: ''});
const onChange = e => {
// INVALID! should use copy-on-write and pass the new value
x.value = e.target.value;
setX(x);
};
return <input value={x.value} onChange={onChange} />;
}

import {useEffect, useState} from 'react';
let someGlobal = false;
function Component() {
const [state, setState] = useState(someGlobal);
const setGlobal = () => {
someGlobal = true;
};
const indirectSetGlobal = () => {
setGlobal();
};
indirectSetGlobal();
useEffect(() => {
setState(someGlobal);
}, [someGlobal]);
return <div>{String(state)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @validateNoJSXInTryStatements
import {identity} from 'shared-runtime';
function Component(props) {
let el;
try {
let value;
try {
value = identity(props.foo);
} catch {
el = <div value={value} />;
}
} catch {
return null;
}
return el;
}

// @validateNoJSXInTryStatements
function Component(props) {
let el;
try {
el = <div />;
} catch {
return null;
}
return el;
}

function Component(props) {
let x = [];
let y = x;
if (props.p1) {
x = [];
}
let _ = <Component x={x} />;
// y is MaybeFrozen at this point, since it may alias to x
// (which is the above line freezes)
y.push(props.p2);
return <Component x={x} y={y} />;
}

function Component(props) {
let x = [];
let _ = <Component x={x} />;
// x is Frozen at this point
x.push(props.p2);
return <div>{_}</div>;
}

function Component(props) {
const FooContext = useContext(Foo);
// This function should be memoized, but its mutable range is entangled
// with the useContext call. We can't memoize hooks, therefore the
// reactive scope around the hook + callback is pruned and we're left
// w no memoization of the callback.
//
// Ideally we'd determine that this isn't called during render and can
// therefore be considered "immutable" or otherwise safe to memoize
// independently
const onClick = () => {
FooContext.current = true;
};
return <div onClick={onClick} />;
}

function Component(props) {
const context = useContext(FooContext);
context.value = props.value;
return context.value;
}

import {useEffect} from 'react';
function Component(props) {
let x = null;
while (x == null) {
x = props.value;
}
let y = x;
let mutateProps = () => {
y.foo = true;
};
let mutatePropsIndirect = () => {
mutateProps();
};
useEffect(() => mutatePropsIndirect(), [mutatePropsIndirect]);
}

function Component(props) {
const items = [];
for (const x of props.items) {
x.modified = true;
items.push(x);
}
return items;
}

function useInvalidMutation(options) {
function test() {
foo(options.foo); // error should not point on this line
options.foo = 'bar';
}
return test;
}

function Component(props) {
let x = cond ? someGlobal : props.foo;
const mutatePhiThatCouldBeProps = () => {
x.y = true;
};
const indirectMutateProps = () => {
mutatePhiThatCouldBeProps();
};
useEffect(() => indirectMutateProps(), []);
}

import {useEffect} from 'react';
function Component() {
let local;
const mk_reassignlocal = () => {
// Create the reassignment function inside another function, then return it
const reassignLocal = newValue => {
local = newValue;
};
return reassignLocal;
};
const reassignLocal = mk_reassignlocal();
const onMount = newValue => {
reassignLocal('hello');
if (local === newValue) {
// Without React Compiler, `reassignLocal` is freshly created
// on each render, capturing a binding to the latest `local`,
// such that invoking reassignLocal will reassign the same
// binding that we are observing in the if condition, and
// we reach this branch
console.log('`local` was updated!');
} else {
// With React Compiler enabled, `reassignLocal` is only created
// once, capturing a binding to `local` in that render pass.
// Therefore, calling `reassignLocal` will reassign the wrong
// version of `local`, and not update the binding we are checking
// in the if condition.
//
// To protect against this, we disallow reassigning locals from
// functions that escape
throw new Error('`local` not updated!');
}
};
useEffect(() => {
onMount();
}, [onMount]);
return 'ok';
}

// @validatePreserveExistingMemoizationGuarantees
function Component(props) {
const data = useMemo(() => {
// actual code is non-optional
return props.items.edges.nodes ?? [];
// deps are optional
}, [props.items?.edges?.nodes]);
return <Foo data={data} />;
}

function Component(props) {
return foo(useFoo);
}

function Component(props) {
return <Child foo={useFoo} />;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
const x = foo(ref);
return x.current;
}

function Component(props) {
const f = () => {
props.value = true;
};
const g = () => {
f();
};
g();
}

function Component(props) {
const x = makeObject();
// freeze
<div>{x}</div>;
x.y = true;
return x;
}

function Component(props) {
const mutateProps = () => {
props.value = true;
};
const indirectMutateProps = () => {
mutateProps();
};
useEffect(() => indirectMutateProps(), []);
}

function component(a, b) {
let x = React.useMemo(async () => {
await a;
}, []);
return x;
}

// @validateRefAccessDuringRender @compilationMode(infer)
function Component({ref}) {
const value = ref.current;
return <div>{value}</div>;
}

// @validateRefAccessDuringRender @compilationMode(infer)
function Component(props) {
const value = props.ref.current;
return <div>{value}</div>;
}

function Component() {
const x = 0;
x = 1;
}

function useFoo() {
let x = 0;
return value => {
x = value;
};
}

function Component() {
let value = null;
const reassign = async () => {
await foo().then(result => {
// Reassigning a local variable in an async function is *always* mutating
// after render, so this should error regardless of where this ends up
// getting called
value = result;
});
};
const onClick = async () => {
await reassign();
};
return <div onClick={onClick}>Click</div>;
}

import {useEffect} from 'react';
function Component() {
let local;
const reassignLocal = newValue => {
local = newValue;
};
const onMount = newValue => {
reassignLocal('hello');
if (local === newValue) {
// Without React Compiler, `reassignLocal` is freshly created
// on each render, capturing a binding to the latest `local`,
// such that invoking reassignLocal will reassign the same
// binding that we are observing in the if condition, and
// we reach this branch
console.log('`local` was updated!');
} else {
// With React Compiler enabled, `reassignLocal` is only created
// once, capturing a binding to `local` in that render pass.
// Therefore, calling `reassignLocal` will reassign the wrong
// version of `local`, and not update the binding we are checking
// in the if condition.
//
// To protect against this, we disallow reassigning locals from
// functions that escape
throw new Error('`local` not updated!');
}
};
useEffect(() => {
onMount();
}, [onMount]);
return 'ok';
}

import {useEffect} from 'react';
import {useIdentity} from 'shared-runtime';
function Component() {
let local;
const reassignLocal = newValue => {
local = newValue;
};
const callback = newValue => {
reassignLocal('hello');
if (local === newValue) {
// Without React Compiler, `reassignLocal` is freshly created
// on each render, capturing a binding to the latest `local`,
// such that invoking reassignLocal will reassign the same
// binding that we are observing in the if condition, and
// we reach this branch
console.log('`local` was updated!');
} else {
// With React Compiler enabled, `reassignLocal` is only created
// once, capturing a binding to `local` in that render pass.
// Therefore, calling `reassignLocal` will reassign the wrong
// version of `local`, and not update the binding we are checking
// in the if condition.
//
// To protect against this, we disallow reassigning locals from
// functions that escape
throw new Error('`local` not updated!');
}
};
useIdentity(() => {
callback();
});
return 'ok';
}

function Component() {
let local;
const reassignLocal = newValue => {
local = newValue;
};
const onClick = newValue => {
reassignLocal('hello');
if (local === newValue) {
// Without React Compiler, `reassignLocal` is freshly created
// on each render, capturing a binding to the latest `local`,
// such that invoking reassignLocal will reassign the same
// binding that we are observing in the if condition, and
// we reach this branch
console.log('`local` was updated!');
} else {
// With React Compiler enabled, `reassignLocal` is only created
// once, capturing a binding to `local` in that render pass.
// Therefore, calling `reassignLocal` will reassign the wrong
// version of `local`, and not update the binding we are checking
// in the if condition.
//
// To protect against this, we disallow reassigning locals from
// functions that escape
throw new Error('`local` not updated!');
}
};
return <button onClick={onClick}>Submit</button>;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
const renderItem = item => {
const current = ref.current;
return <Foo item={item} current={current} />;
};
return <Items>{props.items.map(item => renderItem(item))}</Items>;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
return <Foo ref={ref.current} />;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef(null);
ref.current = props.value;
return ref.current;
}

// @validateRefAccessDuringRender
function Component(props) {
const ref = useRef({inner: null});
ref.current.inner = props.value;
return ref.current.inner;
}

// @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';
function Component() {
const [state, setState] = useState(0);
const f = () => {
setState(s => s + 1);
};
const g = () => {
f();
};
useEffect(() => {
g();
});
return state;
}

// @validateNoSetStateInPassiveEffects
import {useEffect, useState} from 'react';
function Component() {
const [state, setState] = useState(0);
useEffect(() => {
setState(s => s + 1);
});
return state;
}

import {useCallback} from 'react';
function useKeyedState({key, init}) {
const [prevKey, setPrevKey] = useState(key);
const [state, setState] = useState(init);
const fn = useCallback(() => {
setPrevKey(key);
setState(init);
});
useMemo(() => {
fn();
}, [key, init]);
return state;
}

function useKeyedState({key, init}) {
const [prevKey, setPrevKey] = useState(key);
const [state, setState] = useState(init);
useMemo(() => {
setPrevKey(key);
setState(init);
}, [key, init]);
return state;
}

/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
'use forget';
const x = [];
// eslint-disable-next-line react-hooks/rules-of-hooks
return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */

function Component(props) {
const x = props.cond ? useA : useB;
return x();
}

import ReactCompilerTest from 'ReactCompilerTest';
function Component() {
return ReactCompilerTest.useHookNotTypedAsHook();
}

import {useHookNotTypedAsHook} from 'ReactCompilerTest';
function Component() {
return useHookNotTypedAsHook();
}

import foo from 'useDefaultExportNotTypedAsHook';
function Component() {
return <div>{foo()}</div>;
}

import {notAhookTypedAsHook} from 'ReactCompilerTest';
function Component() {
return <div>{notAhookTypedAsHook()}</div>;
}

// Note: Everything below this is sketchy
/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
'use forget';
const x = [];
return <div>{x}</div>;
}
function Haunted() {
return <div>This entire file is haunted oOoOo</div>;
}
function CrimesAgainstReact() {
let x = React.useMemo(async () => {
await a;
}, []);
class MyAmazingInnerComponent {
render() {
return <div>Why would you do this</div>;
}
}
// Note: This shouldn't reset the eslint suppression to just this line
// eslint-disable-next-line react-hooks/rules-of-hooks
return <MyAmazingInnerComponent />;
}

// @validateNoSetStateInRender
function Component(props) {
const [x, setX] = useState(0);
const aliased = setX;
setX(1);
aliased(2);
return x;
}

// @validateRefAccessDuringRender
function Foo({a}) {
const ref = useRef();
// type information is lost here as we don't track types of fields
const val = {ref};
// without type info, we don't know that val.ref.current is a ref value so we
// *would* end up depending on val.ref.current
// however, this is an instance of accessing a ref during render and is disallowed
// under React's rules, so we reject this input
const x = {a, val: val.ref.current};
return <VideoList videos={x} />;
}

// @validateMemoizedEffectDependencies
function Component(props) {
// Items cannot be memoized bc its mutation spans a hook call
const items = [props.value];
const [state, _setState] = useState(null);
mutate(items);
// Items is no longer mutable here, but it hasn't been memoized
useEffect(() => {
console.log(items);
}, [items]);
return [items, state];
}

// @validateMemoizedEffectDependencies
import {useEffect} from 'react';
function Component(props) {
const data = {};
useEffect(() => {
console.log(props.value);
}, [data]);
mutate(data);
return data;
}

// @validateMemoizedEffectDependencies
import {useInsertionEffect} from 'react';
function Component(props) {
const data = {};
useInsertionEffect(() => {
console.log(props.value);
}, [data]);
mutate(data);
return data;
}

// @validateMemoizedEffectDependencies
import {useLayoutEffect} from 'react';
function Component(props) {
const data = {};
useLayoutEffect(() => {
console.log(props.value);
}, [data]);
mutate(data);
return data;
}

function component(a, b) {
let x = useMemo(async () => {
await a;
}, []);
return x;
}

function component(a, b) {
let x = useMemo(c => a, []);
return x;
}

// @validateRefAccessDuringRender
function useHook({value}) {
const ref = useRef(null);
// Writing to a ref in render is against the rules:
ref.current = value;
// returning a ref is allowed, so this alone doesn't trigger an error:
return ref;
}

// @validateRefAccessDuringRender @compilationMode(infer)
function Component(props) {
const ref = props.ref;
ref.current = true;
return <div>{value}</div>;
}

import {useState} from 'react';
function Foo() {
const [state, setState] = useState({foo: {bar: 3}});
const foo = state.foo;
foo.bar = 1;
return state;
}

import {useState} from 'react';
function Foo() {
let [state, setState] = useState({});
state.foo = 1;
return state;
}

import {useReducer} from 'react';
function Foo() {
let [state, setState] = useReducer({foo: 1});
state.foo = 1;
return state;
}

// @enableAssumeHooksFollowRulesOfReact @enableTransitivelyFreezeFunctionExpressions
let cond = true;
function Component(props) {
let a;
let b;
const f = () => {
if (cond) {
a = {};
b = [];
} else {
a = {};
b = [];
}
a.property = true;
b.push(false);
};
return <div onClick={f()} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

export function ViewModeSelector(props) {
const renderIcon = () => <AcceptIcon />;
renderIcon.displayName = 'AcceptIcon';
return <Dropdown checkableIndicator={{children: renderIcon}} />;
}

let renderCount = 0;
function NoHooks() {
renderCount++;
return <div />;
}

function useHook(a, b) {
b.test = 1;
a.test = 2;
}

let wat = {};
function Foo() {
delete wat.foo;
return wat;
}

function Foo(props) {
props.test = 1;
return null;
}

// @disableMemoizationForDebugging @enableChangeDetectionForDebugging
function Component(props) {}

let x = {a: 42};
function Component(props) {
foo(() => {
x.a = 10;
x.a = 20;
});
}

function Foo() {
const x = () => {
window.href = 'foo';
};
const y = {x};
return <Bar y={y} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

function Component() {
const x = Foo.useFoo;
return x();
}

let b = 1;
export default function MyApp() {
const fn = () => {
b = 2;
};
return foo(fn);
}
function foo(fn) {}
export const FIXTURE_ENTRYPOINT = {
fn: MyApp,
params: [],
};

function Component() {
const foo = () => {
// Cannot assign to globals
someUnknownGlobal = true;
moduleLocal = true;
};
foo();
}

function Component() {
// Cannot assign to globals
someUnknownGlobal = true;
moduleLocal = true;
}

// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';
function useCustomRef() {
return useRef({click: () => {}});
}
function Foo() {
const notaref = useCustomRef();
const onClick = useCallback(() => {
notaref.current?.click();
}, []);
return <button onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
isComponent: true,
};

// @validatePreserveExistingMemoizationGuarantees
import {useCallback, useRef} from 'react';
function useCustomRef() {
return useRef({click: () => {}});
}
function Foo() {
const Ref = useCustomRef();
const onClick = useCallback(() => {
Ref.current?.click();
}, []);
return <button onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
isComponent: true,
};

function Component() {
const item = [];
const foo = useCallback(
() => {
item.push(1);
}, // eslint-disable-next-line react-hooks/exhaustive-deps
[]
);
return <Button foo={foo} />;
}

/* eslint-disable react-hooks/rules-of-hooks */
function lowercasecomponent() {
const x = [];
return <div>{x}</div>;
}
/* eslint-enable react-hooks/rules-of-hooks */
export const FIXTURE_ENTRYPOINT = {
fn: lowercasecomponent,
params: [],
isComponent: false,
};

let wat = {};
function Foo() {
wat.test = 1;
return wat;
}

async function Component({items}) {
const x = [];
for await (const item of items) {
x.push(item);
}
return x;
}

import {useHook} from 'shared-runtime';
function Component(props) {
const data = useHook();
const items = [];
// NOTE: `item` is a context variable because it's reassigned and also referenced
// within a closure, the `onClick` handler of each item
for (let key in props.data) {
key = key ?? null; // no-op reassignment to force a context variable
items.push(
<div key={key} onClick={() => data.set(key)}>
{key}
</div>
);
}
return <div>{items}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{data: {a: 'a', b: true, c: 'hello'}}],
};

function Component() {
const data = useData();
const items = [];
// NOTE: `i` is a context variable because it's reassigned and also referenced
// within a closure, the `onClick` handler of each item
for (let i = MIN; i <= MAX; i += INCREMENT) {
items.push(<Stringify key={i} onClick={() => data.set(i)} />);
}
return items;
}

import {useHook} from 'shared-runtime';
function Component(props) {
const data = useHook();
const items = [];
// NOTE: `item` is a context variable because it's reassigned and also referenced
// within a closure, the `onClick` handler of each item
for (let item of props.data) {
item = item ?? {}; // reassignment to force a context variable
items.push(
<div key={item.id} onClick={() => data.set(item)}>
{item.id}
</div>
);
}
return <div>{items}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{data: [{id: '1'}, {id: '2'}]}],
};

function Component() {
let callback = () => {
onClick = () => {};
};
let onClick;
return <div onClick={callback} />;
}

function useFoo() {
let counter = 2;
const fn = () => {
return counter++;
};
return fn();
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [],
};

function Component() {
return get2();
function get2() {
return 2;
}
}

// @compilationMode(infer)
function Component() {
return <Foo />;
// This is unreachable from a control-flow perspective, but it gets hoisted
function Foo() {}
}

function hoisting() {
function addOne(b) {
// a is undefined (only the declaration is hoisted, not the init) but shouldn't throw
return a + b;
}
const result = addOne(2);
var a = 1;
return result; // OK: returns NaN. The code is semantically wrong but technically correct
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

// @validateNoJSXInTryStatements
import {identity} from 'shared-runtime';
function Component(props) {
let el;
try {
let value;
try {
value = identity(props.foo);
} catch {
el = <div value={value} />;
}
} finally {
console.log(el);
}
return el;
}

// @validateNoJSXInTryStatements
function Component(props) {
let el;
try {
el = <div />;
} finally {
console.log(el);
}
return el;
}

function foo([a, b], {c, d, e = 'e'}, f = 'f', ...args) {
let i = 0;
var x = [];
class Bar {
#secretSauce = 42;
constructor() {
console.log(this.#secretSauce);
}
}
const g = {b() {}, c: () => {}};
const {z, aa = 'aa'} = useCustom();
<Button haha={1}></Button>;
<Button>{/** empty */}</Button>;
const j = function bar([quz, qux], ...args) {};
for (; i < 3; i += 1) {
x.push(i);
}
for (; i < 3; ) {
break;
}
for (;;) {
break;
}
graphql`
${g}
`;
graphql`\\t\n`;
for (c of [1, 2]) {
}
for ([v] of [[1], [2]]) {
}
for ({v} of [{v: 1}, {v: 2}]) {
}
for (let x in {a: 1}) {
}
let updateIdentifier = 0;
--updateIdentifier;
++updateIdentifier;
updateIdentifier.y++;
updateIdentifier.y--;
switch (i) {
case 1 + 1: {
}
case foo(): {
}
case x.y: {
}
default: {
}
}
function component(a) {
// Add support for function declarations once we support `var` hoisting.
function t() {}
t();
}
}
let moduleLocal = false;

function Component(props) {
let result;
try {
result = props.cond && props.foo;
} catch (e) {
console.log(e);
}
return result;
}

import {makeArray} from 'shared-runtime';
function Component(props) {
const items = makeArray(0, 1, 2, null, 4, false, 6);
const max = Math.max(...items.filter(Boolean));
return max;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {Stringify} from 'shared-runtime';
function foo() {
const nt = new.target;
return <Stringify value={nt} />;
}

import {identity, mutate, mutateAndReturn} from 'shared-runtime';
function Component(props) {
const key = {};
const context = {
[(mutate(key), key)]: identity([props.value]),
};
mutate(key);
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {identity, mutate, mutateAndReturn} from 'shared-runtime';
function Component(props) {
const key = {};
const context = {
[mutateAndReturn(key)]: identity([props.value]),
};
mutate(key);
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {identity, mutate, mutateAndReturn} from 'shared-runtime';
function Component(props) {
const key = {};
const context = {
[mutateAndReturn(key)]: identity([props.value]),
};
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

function Component({value}) {
const object = {
get value() {
return value;
},
};
return <div>{object.value}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{value: 0}],
sequentialRenders: [{value: 1}, {value: 2}],
};

function Component(props) {
let value;
const object = {
set value(v) {
value = v;
},
};
object.value = props.value;
return <div>{value}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{value: 0}],
sequentialRenders: [{value: 1}, {value: 2}],
};

import {Stringify} from 'shared-runtime';
function Component({foo}) {
let bar = foo.bar;
return (
<Stringify
handler={() => {
foo = true;
}}
/>
);
}

function Component() {
function callback(x) {
if (x == 0) {
return null;
}
return callback(x - 1);
}
return callback(10);
}

function Foo() {
try {
// NOTE: this fixture previously failed during LeaveSSA;
// double-check this code when supporting value blocks in try/catch
for (let i = 0; i < 2; i++) {}
} catch {}
}

// @flow @validatePreserveExistingMemoizationGuarantees
import {useMemo} from 'react';
import {logValue, useFragment, useHook, typedLog} from 'shared-runtime';
component Component() {
const data = useFragment();
const getIsEnabled = () => {
if (data != null) {
return true;
} else {
return {};
}
};
// We infer that getIsEnabled returns a mutable value, such that
// isEnabled is mutable
const isEnabled = useMemo(() => getIsEnabled(), [getIsEnabled]);
// We then infer getLoggingData as capturing that mutable value,
// so any calls to this function are then inferred as extending
// the mutable range of isEnabled
const getLoggingData = () => {
return {
isEnabled,
};
};
// The call here is then inferred as an indirect mutation of isEnabled
useHook(getLoggingData());
return <div onClick={() => typedLog(getLoggingData())} />;
}

// @flow @validatePreserveExistingMemoizationGuarantees
import {useFragment} from 'react-relay';
import LogEvent from 'LogEvent';
import {useCallback, useMemo} from 'react';
component Component(id) {
const items = useFragment();
const [index, setIndex] = useState(0);
const logData = useMemo(() => {
const item = items[index];
return {
key: item.key,
};
}, [index, items]);
const setCurrentIndex = useCallback(
(index: number) => {
const object = {
tracking: logData.key,
};
// We infer that this may mutate `object`, which in turn aliases
// data from `logData`, such that `logData` may be mutated.
LogEvent.log(() => object);
setIndex(index);
},
[index, logData, items]
);
if (prevId !== id) {
setCurrentIndex(0);
}
return (
<Foo
index={index}
items={items}
current={mediaList[index]}
setCurrentIndex={setCurrentIndex}
/>
);
}

function Component(props) {
function hasErrors() {
let hasErrors = false;
if (props.items == null) {
hasErrors = true;
}
return hasErrors;
}
return hasErrors();
}

// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender
import {useCallback, useRef} from 'react';
function Component(props) {
const ref = useRef({inner: null});
const onChange = useCallback(event => {
// The ref should still be mutable here even though function deps are frozen in
// @enablePreserveExistingMemoizationGuarantees mode
ref.current.inner = event.target.value;
});
// The ref is modified later, extending its range and preventing memoization of onChange
ref.current.inner = null;
return <input onChange={onChange} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component(props) {
return (
useMemo(() => {
return [props.value];
}) || []
);
}

function Component(props) {
let x;
try {
throw [];
} catch (e) {
x.push(e);
}
return x;
}

// @validateNoSetStateInRender
function Component(props) {
const [state, setState] = useState(false);
for (const _ of props) {
if (props.cond) {
break;
} else {
continue;
}
}
setState(true);
return state;
}

// @validateNoSetStateInRender
function Component(props) {
const [state, setState] = useState(false);
for (const _ of props) {
}
setState(true);
return state;
}

// @validateNoSetStateInRender
function Component(props) {
const [state, setState] = useState(false);
for (const _ of props) {
if (props.cond) {
break;
} else {
throw new Error('bye!');
}
}
setState(true);
return state;
}

// @validateNoSetStateInRender
function Component(props) {
const [x, setX] = useState(0);
const foo = () => {
setX(1);
};
foo();
return [x];
}

// @validateNoSetStateInRender
function Component(props) {
const [x, setX] = useState(0);
const foo = () => {
setX(1);
};
const bar = () => {
foo();
};
const baz = () => {
bar();
};
baz();
return [x];
}

// @enablePreserveExistingMemoizationGuarantees @validateRefAccessDuringRender
import {useCallback, useRef} from 'react';
function Component(props) {
const ref = useRef({inner: null});
const onChange = useCallback(event => {
// The ref should still be mutable here even though function deps are frozen in
// @enablePreserveExistingMemoizationGuarantees mode
ref.current.inner = event.target.value;
});
// The ref is modified later, extending its range and preventing memoization of onChange
const reset = () => {
ref.current.inner = null;
};
reset();
return <input onChange={onChange} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @enablePreserveExistingMemoizationGuarantees:false
import {useCallback, useRef} from 'react';
function Component(props) {
const ref = useRef({inner: null});
const onChange = useCallback(event => {
// The ref should still be mutable here even though function deps are frozen in
// @enablePreserveExistingMemoizationGuarantees mode
ref.current.inner = event.target.value;
});
ref.current.inner = null;
return <input onChange={onChange} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function component(a, b) {
// we don't handle generators at all so this test isn't
// useful for now, but adding this test in case we do
// add support for generators in the future.
let x = useMemo(function* () {
yield a;
}, []);
return x;
}

// @validateMemoizedEffectDependencies
import {useHook} from 'shared-runtime';
function Component(props) {
const x = [];
useHook(); // intersperse a hook call to prevent memoization of x
x.push(props.value);
const y = [x];
useEffect(() => {
console.log(y);
}, [y]);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

// @validateRefAccessDuringRender:true
function Foo(props, ref) {
console.log(ref.current);
return <div>{props.bar}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{bar: 'foo'}, {ref: {cuurrent: 1}}],
isComponent: true,
};

function Component(props) {
const computedKey = props.key;
const {[computedKey]: x} = props.val;
return x;
}

function Component(props) {
// b is an object, must be memoized even though the input is not memoized
const {a, ...b} = props.a;
// d is an array, mut be memoized even though the input is not memoized
const [c, ...d] = props.c;
return <div b={b} d={d}></div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
const x = [];
if (a) {
const y = [];
if (b) {
y.push(c);
}
x.push(<div>{y}</div>);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const a = [props.a];
const b = [props.b];
const c = [props.c];
// We don't do constant folding for non-primitive values (yet) so we consider
// that any of a, b, or c could return here
return (a && b) || c;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
// a can be independently memoized, is not mutated later
const a = [props.a];
// b and c are interleaved and grouped into a single scope,
// but they are independent values. c does not escape, but
// we need to ensure that a is memoized or else b will invalidate
// on every render since a is a dependency.
const b = [];
const c = {};
c.a = a;
b.push(props.b);
return b;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
// a can be independently memoized, is not mutated later
// but a is a dependnecy of b, which is a dependency of c.
// we have to memoize a to avoid breaking memoization of b,
// to avoid breaking memoization of c.
const a = [props.a];
// a can be independently memoized, is not mutated later,
// but is a dependency of d which is part of c's scope.
// we have to memoize b to avoid breaking memoization of c.
const b = [a];
// c and d are interleaved and grouped into a single scope,
// but they are independent values. d does not escape, but
// we need to ensure that b is memoized or else b will invalidate
// on every render since a is a dependency. we also need to
// ensure that a is memoized, since it's a dependency of b.
const c = [];
const d = {};
d.b = b;
c.push(props.b);
return c;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
// a does not need to be memoized ever, even though it's a
// dependency of c, which exists in a scope that has a memoized
// output. it doesn't need to be memoized bc the value is a primitive type.
const a = props.a + props.b;
// b and c are interleaved and grouped into a single scope,
// but they are independent values. c does not escape, but
// we need to ensure that a is memoized or else b will invalidate
// on every render since a is a dependency.
const b = [];
const c = {};
c.a = a;
b.push(props.c);
return b;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const x = [props.a];
const y = x ? props.b : props.c;
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const x = [props.a];
let y;
if (x) {
y = props.b;
} else {
y = props.c;
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const a = [props.a];
let x = props.b;
switch (props.c) {
case a: {
x = props.d;
}
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const a = [props.a];
let x = props.b;
switch (a) {
case true: {
x = props.c;
}
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const [state] = useState(0);
// Test for conflicts with `c` import
const c = state;
const _c = c;
const __c = _c;
const c1 = __c;
const $c = c1;
const array = useMemo(() => [$c], [state]);
return <ValidateMemoization inputs={[state]} output={array} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}, {}],
};

function f(y) {
let x = y;
return x + (x = 2) + x;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function f() {
let x = 1;
return x + (x = 2) + x;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: [],
isComponent: false,
};

function foo(a, b, c) {
let x = [];
if (a) {
if (b) {
if (c) {
x.push(0);
}
}
}
if (x.length) {
return x;
}
return null;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @compilationMode(infer)
import {useEffect, useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';
let pretendConst = 0;
function unsafeResetConst() {
pretendConst = 0;
}
function unsafeUpdateConst() {
pretendConst += 1;
}
function Component() {
useState(() => {
// unsafe: reset the constant when first rendering the instance
unsafeResetConst();
});
// UNSAFE! changing a module variable that is read by a component is normally
// unsafe, but in this case we're simulating a fast refresh between each render
unsafeUpdateConst();
// In production mode (no @enableResetCacheOnSourceFileChanges) memo caches are not
// reset unless the deps change
const value = useMemo(() => [{pretendConst}], []);
return <ValidateMemoization inputs={[]} output={value} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}],
};

// @compilationMode(infer) @enableResetCacheOnSourceFileChanges
import {useEffect, useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';
let pretendConst = 0;
function unsafeResetConst() {
pretendConst = 0;
}
function unsafeUpdateConst() {
pretendConst += 1;
}
function Component() {
useState(() => {
// unsafe: reset the constant when first rendering the instance
unsafeResetConst();
});
// UNSAFE! changing a module variable that is read by a component is normally
// unsafe, but in this case we're simulating a fast refresh between each render
unsafeUpdateConst();
// TODO: In fast refresh mode (@enableResetCacheOnSourceFileChanges) Forget should
// reset on changes to globals that impact the component/hook, effectively memoizing
// as if value was reactive. However, we don't want to actually treat globals as
// reactive (though that would be trivial) since it could change compilation too much
// btw dev and prod. Instead, we should reset the cache via a secondary mechanism.
const value = useMemo(() => [{pretendConst}], [pretendConst]);
return <ValidateMemoization inputs={[pretendConst]} output={value} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}],
};

// @enableResetCacheOnSourceFileChanges
import {useMemo, useState} from 'react';
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const [state, setState] = useState(0);
const doubled = useMemo(() => [state * 2], [state]);
return <ValidateMemoization inputs={[state]} output={doubled} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}],
};

const {ObjectWithHooks} = require('shared-runtime');
function Component(props) {
const x = [];
const [y] = ObjectWithHooks.useMakeArray();
x.push(y);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component(props) {
let x = 0;
for (let i = 0; i < props.count; ) {
x += i;
i += 1;
continue;
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x = 0;
for (let i = 0; i < props.count; ) {
x += i;
if (x > 10) {
break;
}
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
for (const x in props.value) {
return x;
}
return null;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: {a: 'A!'}}],
};

function Component(props) {
let x;
const object = {...props.value};
for (const y in object) {
if (y === 'break') {
break;
}
x = object[y];
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
// should return 'a'
params: [{a: 'a', break: null, c: 'C!'}],
};

function Component(props) {
let x;
const object = {...props.value};
for (const y in object) {
if (y === 'continue') {
continue;
}
x = object[y];
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: {a: 'a', continue: 'skip', b: 'hello!'}}],
sequentialRenders: [
{value: {a: 'a', continue: 'skip', b: 'hello!'}},
{value: {a: 'a', continue: 'skip', b: 'hello!'}},
{value: {a: 'skip!', continue: true}},
{value: {a: 'a', continue: 'skip', b: 'hello!'}},
{value: {a: 'skip!', continue: true}},
{value: {a: 'a', continue: 'skip', b: 'hello!'}},
{value: {a: 'skip!', continue: true}},
{value: {a: 'skip!', continue: true}},
],
};

function Component(props) {
let x;
for (const y in props.value) {
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: {a: 'a', b: 'B', c: 'C!'}}],
};

const {identity, mutate} = require('shared-runtime');
function Component(props) {
let x;
const object = {...props.value};
for (const y in object) {
x = y;
}
mutate(x); // can't modify, x is known primitive!
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: {a: 'a', b: 'B', c: 'C!'}}],
};

function Component(props) {
let items = [];
for (const key in props) {
items.push(<div key={key}>{key}</div>);
}
return <div>{items}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{hello: null, world: undefined, '!': true}],
sequentialRenders: [
{a: null, b: null, c: null},
{lauren: true, mofei: true, sathya: true, jason: true},
],
};

function foo(props) {
let y = 0;
for (
let x = 0;
x > props.min && x < props.max;
x += props.cond ? props.increment : 2
) {
x *= 2;
y += x;
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// These variables are unknown to useFoo, as they are
// defined at module scope or implicit globals
const isSelected = false;
const isCurrent = true;
function useFoo() {
for (let i = 0; i <= 5; i++) {
let color;
if (isSelected) {
color = isCurrent ? '#FFCC22' : '#FF5050';
} else {
color = isCurrent ? '#CCFF03' : '#CCCCCC';
}
console.log(color);
}
}
export const FIXTURE_ENTRYPOINT = {
params: [],
fn: useFoo,
};

const TOTAL = 10;
function Component(props) {
const items = [];
for (let i = props.start ?? 0; i < props.items.length; i++) {
const item = props.items[i];
items.push(<div key={item.id}>{item.value}</div>);
}
return <div>{items}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [
{
start: null,
items: [
{id: 0, value: 'zero'},
{id: 1, value: 'one'},
],
},
],
sequentialRenders: [
{
start: 1,
items: [
{id: 0, value: 'zero'},
{id: 1, value: 'one'},
],
},
{
start: 2,
items: [
{id: 0, value: 'zero'},
{id: 1, value: 'one'},
],
},
{
start: 0,
items: [
{id: 0, value: 'zero'},
{id: 1, value: 'one'},
{id: 2, value: 'two'},
],
},
{
start: 1,
items: [
{id: 0, value: 'zero'},
{id: 1, value: 'one'},
{id: 2, value: 'two'},
],
},
],
};

function Component(props) {
const items = [];
for (let i = 0, length = props.items.length; i < length; i++) {
items.push(props.items[i]);
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: ['a', 'b', 42]}],
};

function Component() {
const x = [];
for (const item of [1, 2]) {
break;
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

import {makeObject_Primitives} from 'shared-runtime';
function Component(props) {
let lastItem = null;
const items = [makeObject_Primitives(), makeObject_Primitives()];
for (const x of items) {
lastItem = x;
}
if (lastItem != null) {
lastItem.a += 1;
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}, {}],
};

import {makeObject_Primitives} from 'shared-runtime';
function Component(props) {
let lastItem = {};
const items = [makeObject_Primitives(), makeObject_Primitives()];
for (const x of items) {
lastItem = x;
}
if (lastItem != null) {
lastItem.a += 1;
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}],
};

function Component() {
const x = [];
for (const item of [1, 2]) {
if (item === 1) {
break;
}
x.push(item);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component() {
const x = [0, 1, 2, 3];
const ret = [];
for (const item of x) {
if (item === 0) {
continue;
}
ret.push(item / 2);
}
return ret;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component() {
let x = [];
let items = [{v: 0}, {v: 1}, {v: 2}];
for (const {v} of items) {
x.push(v * 2);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Router({title, mapping}) {
const array = [];
for (let [, entry] of mapping) {
array.push([title, entry]);
}
return array;
}
const routes = new Map([
['about', '/about'],
['contact', '/contact'],
]);
export const FIXTURE_ENTRYPOINT = {
fn: Router,
params: [],
sequentialRenders: [
{
title: 'Foo',
mapping: routes,
},
{
title: 'Bar',
mapping: routes,
},
],
};

function Router({title, mapping}) {
const array = [];
for (let entry of mapping.values()) {
array.push([title, entry]);
}
return array;
}
const routes = new Map([
['about', '/about'],
['contact', '/contact'],
]);
export const FIXTURE_ENTRYPOINT = {
fn: Router,
params: [],
sequentialRenders: [
{
title: 'Foo',
mapping: routes,
},
{
title: 'Bar',
mapping: routes,
},
],
};

import {makeObject_Primitives} from 'shared-runtime';
function Component(props) {
const items = [makeObject_Primitives(), makeObject_Primitives()];
for (const x of items) {
x.a += 1;
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
sequentialRenders: [{}, {}, {}],
};

import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';
function Component({a, b}) {
const x = useMemo(() => {
return [a];
}, [a]);
const y = useMemo(() => {
const items = [b];
for (const i of x) {
items.push(i);
}
return items;
}, [x, b]);
return (
<>
<ValidateMemoization inputs={[a]} output={x} />
<ValidateMemoization inputs={[x, b]} output={y} />
</>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 0, b: 0}],
sequentialRenders: [
{a: 1, b: 0},
{a: 1, b: 1},
{a: 0, b: 1},
],
};

function Component() {
let x = [];
let items = [0, 1, 2];
for (const ii of items) {
x.push(ii * 2);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component(props) {
for (let i = 0; i < props.count; i++) {
return;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x = props.init;
for (let i = 0; i < 100; i = i + 1) {
x += i;
}
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{init: 0}],
};

function Component() {
const a = [];
const b = a;
useFreeze(a);
foo(b); // should be readonly, value is guaranteed frozen via alias
return b;
}
function useFreeze() {}
function foo(x) {}

function component() {
function x(a) {
a.foo();
}
x = {};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [],
isComponent: false,
};

function component() {
function x(a) {
a.foo();
}
function x() {}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [],
isComponent: false,
};

function component(a) {
let t = {a};
function x(p) {
p.foo();
}
x(t);
return t;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component() {
'use strict';
let [count, setCount] = React.useState(0);
function update() {
'worklet';
setCount(count => count + 1);
}
return <button onClick={update}>{count}</button>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: true,
};

function Component(props) {
let x = {};
// onChange should be inferred as immutable, because the value
// it captures (`x`) is frozen by the time the function is referenced
const onChange = e => {
maybeMutate(x, e.target.value);
};
if (props.cond) {
<div>{x}</div>;
}
return <Foo value={x} onChange={onChange} />;
}

function Component(props) {
const id = useSelectedEntitytId();
// this example should infer `id` as mutable, and then infer `onLoad` as mutable,
// and be rejected because onLoad cannot be passed as a frozen value in the JSX.
// however, we likely have to allow this example to work, because hook return
// values are generally immutable in practice and are also widely referenced in
// callbacks.
const onLoad = () => {
log(id);
};
return <Foo onLoad={onLoad} />;
}

import {useMemo} from 'react';
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const a = useMemo(() => {
const a = [];
const f = function () {
a.push(props.name);
};
f.call();
return a;
}, [props.name]);
return <ValidateMemoization inputs={[props.name]} output={a} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{name: 'Jason'}],
sequentialRenders: [{name: 'Lauren'}, {name: 'Lauren'}, {name: 'Jason'}],
};

function Component(props) {
const f = function () {
return <div>{props.name}</div>;
};
return f.call();
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{name: 'Jason'}],
};

function Component(props) {
const mutate = (object, key, value) => {
object.updated = true;
object[key] = value;
};
const x = makeObject(props);
mutate(x);
return x;
}

function Component(x = 'default', y = [{}]) {
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @enableTreatFunctionDepsAsConditional @enablePropagateDepsInHIR:false
function Component(props) {
function getLength() {
return props.bar.length;
}
return props.bar && getLength();
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{bar: null}],
};

// @gating
function Component() {
const name = Component.name;
return <div>{name}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

// @gating @compilationMode(annotation)
export default function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
export default function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
export function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
export function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
export function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
export function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

// @gating @compilationMode(annotation)
function Bar(props) {
'use forget';
return <div>{props.bar}</div>;
}
function NoForget(props) {
return <Bar>{props.noForget}</Bar>;
}
function Foo(props) {
'use forget';
return <Foo>{props.bar}</Foo>;
}

// @flow @gating
import {memo} from 'react';
type Props = React.ElementConfig<typeof Component>;
component Component(value: string) {
return <div>{value}</div>;
}
export default memo<Props>(Component);

function Component(props) {
const maybeMutable = new MaybeMutable();
// NOTE: this will produce invalid output.
// The HIR is roughly:
//                                    mutable range of `maybeMutable`
// StoreLocal maybeMutable = ...
// t0 = LoadGlobal View               <-- View is lowered inside this mutable range
//                                         and thus gets becomes an output of this scope,
//                                         gets promoted to temporary
// t1 = LoadGlobal maybeMutate
// t2 = LoadLocal maybeMutable
// t3 = Call t1(t2)
// t4 = Jsx tag=t0 props=[] children=[t3] <-- `t0` is an invalid tag
return <View>{maybeMutate(maybeMutable)}</View>;
}

function Component(props) {
const x = {};
const y = Boolean(x);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {useState as _useState, useCallback, useEffect} from 'react';
import {ValidateMemoization} from 'shared-runtime';
function useState(value) {
const [state, setState] = _useState(value);
return [state, setState];
}
function Component() {
const [state, setState] = useState('hello');
return <div onClick={() => setState('goodbye')}>{state}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component(props) {
const x = {};
const y = Number(x);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const x = {};
const y = String(x);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

//@flow
component Foo() {
function foo() {
return (
<div>
{a} {z} {y}
</div>
);
}
const [a, {x: z, y = 10}] = [1, {x: 2}];
return foo();
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

import {Stringify} from 'shared-runtime';
function hoisting() {
function onClick() {
return bar['baz'];
}
function onClick2() {
return bar[baz];
}
const baz = 'baz';
const bar = {baz: 1};
return (
<Stringify onClick={onClick} onClick2={onClick2} shouldInvokeFns={true} />
);
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
};

import {Stringify} from 'shared-runtime';
function hoisting() {
function onClick(x) {
return x + bar.baz;
}
const bar = {baz: 1};
return <Stringify onClick={onClick} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

import {print} from 'shared-runtime';
function hoisting(cond) {
if (cond) {
const x = 1;
print(x);
}
const x = 2;
print(x);
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [false],
};

function hoisting(cond) {
let items = [];
if (cond) {
const foo = () => {
items.push(bar());
};
const bar = () => true;
foo();
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [true],
isComponent: false,
};

function hoisting() {
const qux = () => {
let result;
{
result = foo();
}
return result;
};
const foo = () => {
return bar + baz;
};
const bar = 3;
const baz = 2;
return qux(); // OK: called outside of TDZ
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function hoisting(cond) {
let items = [];
if (cond) {
let foo = () => {
items.push(bar());
};
let bar = () => true;
foo();
}
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [true],
isComponent: false,
};

function hoisting() {
let qux = () => {
let result;
{
result = foo();
}
return result;
};
let foo = () => {
return bar + baz;
};
let bar = 3;
const baz = 2;
return qux(); // OK: called outside of TDZ
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function hoisting() {
const x = {
foo() {
return bar();
},
};
const bar = () => {
return 1;
};
return x.foo(); // OK: bar's value is only accessed outside of its TDZ
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
};

function Foo({}) {
const outer = val => {
const fact = x => {
if (x <= 0) {
return 1;
}
return x * fact(x - 1);
};
return fact(val);
};
return outer(3);
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function get2() {
const callbk = () => {
const copy = x;
return copy;
};
const x = 2;
return callbk();
}
export const FIXTURE_ENTRYPOINT = {
fn: get2,
params: [],
};

function hoisting() {
const foo = () => {
return bar + baz;
};
const bar = 3;
const baz = 2;
return foo(); // OK: called outside of TDZ for bar/baz
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function hoisting() {
const foo = () => {
return bar();
};
const bar = () => {
return 1;
};
return foo(); // OK: bar's value is only accessed outside of its TDZ
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function hoisting() {
let foo = () => {
return bar + baz;
};
let bar = 3;
let baz = 2;
return foo(); // OK: called outside of TDZ for bar/baz
}
export const FIXTURE_ENTRYPOINT = {
fn: hoisting,
params: [],
isComponent: false,
};

function Component({}) {
const outer = () => {
const inner = () => {
return x;
};
const x = 3;
return inner();
};
return <div>{outer()}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {CONST_STRING0} from 'shared-runtime';
function t(props) {
let x = [, CONST_STRING0, props];
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: t,
params: [{a: 1, b: 2}],
isComponent: false,
};

function t(props) {
let [foo, bar, ,] = props;
return foo;
}
export const FIXTURE_ENTRYPOINT = {
fn: t,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function t(props) {
let [, foo, bar] = props;
return foo;
}
export const FIXTURE_ENTRYPOINT = {
fn: t,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function t(props) {
let [, setstate] = useState();
setstate(1);
return props.foo;
}
export const FIXTURE_ENTRYPOINT = {
fn: t,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function useFreeze() {}
function foo() {}
function Component(props) {
const x = [];
const y = useFreeze(x);
foo(y, x);
return (
<Component>
{x}
{y}
</Component>
);
}

// @flow @compilationMode(infer)
export default hook useFoo(bar: number) {
return [bar];
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [42],
};

function Component(props) {
const user =
useFragment(
graphql`
fragment F on T {
id
}
`,
props.user
) ?? {};
return user.name;
}

import {useNoAlias} from 'shared-runtime';
function Component(props) {
const item = {a: props.a};
const x = useNoAlias(item, () => {
console.log(props);
}, [props.a]);
return [x, item];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: {id: 42}}],
isComponent: true,
};

function useFoo() {}
function Foo() {
let name = useFoo.name;
console.log(name);
return name;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

function Component() {
const a = [];
useFreeze(a); // should freeze
useFreeze(a); // should be readonly
call(a); // should be readonly
return a;
}
function useFreeze(x) {}
function call(x) {}

function Component(props) {
const cond = props.cond;
const x = props.x;
let a;
if (cond) {
a = x;
} else {
a = [];
}
useFreeze(a); // should freeze, value *may* be mutable
useFreeze(a); // should be readonly
call(a); // should be readonly
return a;
}
function useFreeze(x) {}
function call(x) {}

// @hookPattern:".*\b(use[^$]+)$"
import * as React from 'react';
import {makeArray, useHook} from 'shared-runtime';
const React$useState = React.useState;
const React$useMemo = React.useMemo;
const Internal$Reassigned$useHook = useHook;
function Component() {
const [state, setState] = React$useState(0);
const object = Internal$Reassigned$useHook();
const json = JSON.stringify(object);
const doubledArray = React$useMemo(() => {
return makeArray(state);
}, [state]);
return (
<div>
{doubledArray.join('')}
{json}
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component() {
const [x, setX] = React.useState(1);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
};

// @customMacros(idx.*.b)
function Component(props) {
// outlined
const groupName1 = idx(props, _ => _.group.label);
// outlined
const groupName2 = idx.a(props, _ => _.group.label);
// not outlined
const groupName3 = idx.a.b(props, _ => _.group.label);
// not outlined
const groupName4 = idx.hello_world.b(props, _ => _.group.label);
// outlined
const groupName5 = idx.hello_world.b.c(props, _ => _.group.label);
return (
<div>
{groupName1}
{groupName2}
{groupName3}
{groupName4}
{groupName5}
</div>
);
}

// @customMacros(idx.a)
function Component(props) {
// outlined
const groupName1 = idx(props, _ => _.group.label);
// not outlined
const groupName2 = idx.a(props, _ => _.group.label);
// outlined
const groupName3 = idx.a.b(props, _ => _.group.label);
return (
<div>
{groupName1}
{groupName2}
{groupName3}
</div>
);
}

// @customMacros(idx)
import idx from 'idx';
function Component(props) {
// the lambda should not be outlined
const groupName = idx(props, _ => _.group.label);
return <div>{groupName}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @ignoreUseNoForget
function Component(prop) {
'use no forget';
const result = prop.x.toFixed();
return <div>{result}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: 1}],
};

function Component(props) {
const items = (() => {
if (props.cond) {
return [];
} else {
return null;
}
})();
items?.push(props.a);
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: {}}],
};

function Component(props) {
const items = (() => {
return [];
})();
items.push(props.a);
return items;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: {}}],
};

// @enableAssumeHooksFollowRulesOfReact true
function Component(props) {
const x = {};
// In enableAssumeHooksFollowRulesOfReact mode hooks freeze their inputs and return frozen values
const y = useFoo(x);
// Thus both x and y are frozen here, and x can be independently memoized
bar(x, y);
return [x, y];
}

function Component(props) {
const env = useRelayEnvironment();
// Note: this is a class has no mutable methods, ie it always treats `this` as readonly
const mutator = new Mutator(env);
useOtherHook();
// `x` should be independently memoizeable, since foo(x, mutator) cannot mutate
// the mutator.
const x = {};
foo(x, mutator);
return x;
}
class Mutator {}

function Component(props) {
const [value, setValue] = useState(null);
// NOTE: this lambda does not capture any mutable values (only the state setter)
// and thus should be treated as readonly
const onChange = e => setValue(value => value + e.target.value);
useOtherHook();
// x should be independently memoizeable, since foo(x, onChange) cannot modify onChange
const x = {};
foo(x, onChange);
return x;
}

import {useMemo} from 'react';
import {Stringify} from 'shared-runtime';
function Component({}) {
let a = 'a';
let b = '';
[a, b] = [null, null];
// NOTE: reference `a` in a callback to force a context variable
return <Stringify a={a} b={b} onClick={() => a} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function compute() {}
function mutate() {}
function foo() {}
function Foo() {}
/**
* Should produce 3 scopes:
*
* a: inputs=props.a & props.c; outputs=a
*   a = compute(props.a);
*   if (props.c)
*     mutate(a)
* b: inputs=props.b & props.c; outputs=b
*   b = compute(props.b);
*   if (props.c)
*     mutate(b)
* return: inputs=a, b outputs=return
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
if (props.c) {
mutate(a);
mutate(b);
}
return <Foo a={a} b={b} />;
}

/**
* Should produce 3 scopes:
*
* a: inputs=props.a, outputs=a
*   a = compute(props.a);
* b: inputs=props.b, outputs=b
*   b = compute(props.b);
* return: inputs=a, b outputs=return
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
return <Foo a={a} b={b} />;
}
function compute() {}
function foo() {}
function Foo() {}

function foo(a, b, c) {
const x = {a: a};
// NOTE: this array should memoize independently from x, w only b,c as deps
x.y = [b, c];
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @compilationMode(infer)
import {useNoAlias} from 'shared-runtime';
// This should be compiled by Forget
function useFoo(value1, value2) {
return {
value: useNoAlias(value1 + value2),
};
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [1, 2],
};

// @debug
function Component(props) {
const x = makeObject();
const y = delete x[props.value];
return y;
}

// @compilationMode(infer)
// Takes multiple parameters - not a component!
function Component(foo, bar) {
return <div />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [null, null],
};

// @compilationMode(infer)
const Component = props => {
return <div />;
};

// @compilationMode(infer)
const Component = function ComponentName(props) {
return <Foo />;
};

// @gating @compilationMode(infer)
import React from 'react';
export default React.forwardRef(function notNamedLikeAComponent(props) {
return <div />;
});

// @compilationMode(infer)
React.forwardRef(props => {
return <div />;
});

// @compilationMode(infer)
React.memo(props => {
return <div />;
});

// @compilationMode(infer)
function Component(props) {
const [state, _] = useState(null);
return [state];
}

// @compilationMode(infer)
function Component(props) {
return <div />;
}

// @compilationMode(infer)
function Foo({}, ref) {
return <div ref={ref} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

// @compilationMode(infer)
function useStateValue(props) {
const [state, _] = useState(null);
return [state];
}

// @compilationMode(infer)
function useDiv(props) {
return <div />;
}

import {identity, sum} from 'shared-runtime';
// Check that we correctly resolve type and effect lookups on the javascript
// global object.
function Component(props) {
let neverAliasedOrMutated = identity(props.b);
let primitiveVal1 = Math.max(props.a, neverAliasedOrMutated);
let primitiveVal2 = Infinity;
let primitiveVal3 = globalThis.globalThis.NaN;
// Even though we don't know the function signature of sum,
// we should be able to infer that it does not mutate its inputs.
sum(primitiveVal1, primitiveVal2, primitiveVal3);
return {primitiveVal1, primitiveVal2, primitiveVal3};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 1, b: 2}],
isComponent: false,
};

// @compilationMode(infer)
function Component(props) {
const result = f(props);
function helper() {
return <foo />;
}
helper();
return result;
}
function f(props) {
return props;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @compilationMode(infer)
function Component(props) {
const ignore = <foo />;
return {foo: f(props)};
}
function f(props) {
return props;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function foo(a, b) {
let x;
if (a) {
x = 1;
} else {
x = 2;
}
let y = x;
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [true, false],
isComponent: false,
};

function Component(props) {
const x = makeObject();
const y = delete x.value;
return y;
}

// @compilationMode(infer)
// This component is skipped bc it doesn't call any hooks or
// use JSX:
function Component(props) {
return render();
}

// @flow
import {getNumber} from 'shared-runtime';
function Component(props) {
// We can infer that `x` is a primitive bc it is aliased to `y`,
// which is used in a binary expression
const x = getNumber();
const y = (x: any);
y + 1;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function Component(props) {
const item = useFragment(FRAGMENT, props.item);
useFreeze(item);
const count = new MaybeMutable(item);
return (
<View>
<View>
{<span>Text</span>}
{<span>{maybeMutate(count)}</span>}
</View>
</View>
);
}

function Component(props) {
const count = new MaybeMutable();
return (
<View>
<View>
{<span>Text</span>}
{<span>{maybeMutate(count)}</span>}
</View>
</View>
);
}

function compute() {}
function foo() {}
function Foo() {}
/**
* Should produce 1 scope:
*
* return: inputs=props.a & props.b & props.c; outputs=return
*   const a = compute(props.a);
*   const b = compute(props.b);
*   if (props.c)
*     foo(a, b);
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
if (props.c) {
foo(a, b);
}
return <Foo a={a} b={b} />;
}

/**
* Should produce 1 scope:
*
* return: inputs=props.a & props.b; outputs=return
*   const a = compute(props.a);
*   const b = compute(props.b);
*   foo(a, b);
*   return = <Foo a={a} b={b} />
*/
function Component(props) {
const a = compute(props.a);
const b = compute(props.b);
foo(a, b);
return <Foo a={a} b={b} />;
}
function compute() {}
function foo() {}
function Foo() {}

function foo(a, b, c) {
let x = null;
label: {
if (a) {
x = b;
break label;
}
x = c;
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c, d) {
let y = [];
label: if (a) {
if (b) {
y.push(c);
break label;
}
y.push(d);
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(c) {
let x = {c};
mutate(x);
let a = x;
let b = a;
}

function makeObj() {
'use no forget';
const result = [];
result.a = {b: 2};
return result;
}
// This caused an infinite loop in the compiler
function MyApp(props) {
const y = makeObj();
const tmp = y.a;
const tmp2 = tmp.b;
y.push(tmp2);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: MyApp,
params: [],
isComponent: false,
};

// @flow
function Component({items}) {
// Per the spec, <Foo value=<>{...}</> /> is valid.
// But many tools don't allow fragments as jsx attribute values,
// so we ensure not to emit them wrapped in an expression container
return items.length > 0 ? (
<Foo
value={
<Bar>
{items.map(item => (
<Item key={item.id} item={item} />
))}
</Bar>
}></Foo>
) : null;
}
function Foo({value}) {
return value;
}
function Bar({children}) {
return <div>{children}</div>;
}
function Item({item}) {
return <div>{item.name}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: [{id: 1, name: 'One!'}]}],
};

// @flow
import {Stringify} from 'shared-runtime';
function Component({items}) {
// Per the spec, <Foo value=<>{...}</> /> is valid.
// But many tools don't allow fragments as jsx attribute values,
// so we ensure not to emit them wrapped in an expression container
return items.length > 0 ? (
<Foo
value={
<>
{items.map(item => (
<Stringify key={item.id} item={item} />
))}
</>
}></Foo>
) : null;
}
function Foo({value}) {
return <div>{value}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: [{id: 1, name: 'One!'}]}],
};

export function Component(props) {
return (
<div>
{}
{props.a}
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 'hello'}],
};

function Foo(props) {
return (
<>
Hello {props.greeting}{' '}
<div>
<>Text</>
</div>
</>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {jsx as _jsx} from 'react/jsx-runtime';
import {shallowCopy} from 'shared-runtime';
function Component(props) {
const childprops = {style: {width: props.width}};
const element = _jsx('div', {
childprops: childprops,
children: '"hello world"',
});
shallowCopy(childprops); // function that in theory could mutate, we assume not bc createElement freezes
return element;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component() {
return <div>&gt;&lt;span &amp;</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import * as SharedRuntime from 'shared-runtime';
function useFoo({cond}) {
const MyLocal = SharedRuntime;
if (cond) {
return <MyLocal.Text value={4} />;
} else {
return null;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [{cond: true}],
};

import * as SharedRuntime from 'shared-runtime';
function useFoo() {
const MyLocal = SharedRuntime;
return <MyLocal.Text value={4} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [],
};

import {Stringify} from 'shared-runtime';
function useFoo() {
const MyLocal = Stringify;
const callback = () => {
return <MyLocal value={4} />;
};
return callback();
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [],
};

function Component(props) {
const maybeMutable = new MaybeMutable();
return <Foo.Bar>{maybeMutate(maybeMutable)}</Foo.Bar>;
}

function Component(props) {
return (
<Sathya.Codes.Forget>
<Foo.Bar.Baz />
</Sathya.Codes.Forget>
);
}

import * as SharedRuntime from 'shared-runtime';
function useFoo() {
const MyLocal = SharedRuntime;
const callback = () => {
return <MyLocal.Text value={4} />;
};
return callback();
}
export const FIXTURE_ENTRYPOINT = {
fn: useFoo,
params: [],
};

function Component(props) {
return <xml:http protocol:version={props.version} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
return (
<Component {...props} {...{bar: props.cond ? props.foo : props.bar}} />
);
}

function Component() {
return (
<div>
<Text value={'\n'} />
<Text value={'A\tE'} />
<Text value={''} />
<Text value={'Lauren'} />
<Text value={''} />
<Text value={'Sathya'} />
</div>
);
}
function Text({value}) {
return <span>{value}</span>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

function Component() {
return (
<Post
author="potetotes"
text="in addition to understanding JavaScript semantics and the rules of React, the compiler team also understands , , ,  and i think thats pretty cool"
/>
);
}
function Post({author, text}) {
return (
<div>
<h1>{author}</h1>
<span>{text}</span>
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {StaticText1, StaticText2} from 'shared-runtime';
function MaybeMutable() {
return {};
}
function maybeMutate(x) {}
function Component(props) {
const maybeMutable = new MaybeMutable();
let Tag = props.component;
// NOTE: the order of evaluation in the lowering is incorrect:
// the jsx element's tag observes `Tag` after reassignment, but should observe
// it before the reassignment.
// Currently, Forget preserves jsx whitespace in the source text.
// prettier-ignore
return (
<Tag>{((Tag = props.alternateComponent), maybeMutate(maybeMutable))}<Tag /></Tag>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{component: StaticText1, alternateComponent: StaticText2}],
isComponent: true,
};

// Here, element should not be memoized independently of aliasedElement, since
// it is captured by fn.
// AnalyzeFunctions currently does not find captured objects.
//  - mutated context refs are declared as `Capture` effect in `FunctionExpression.deps`
//  - all other context refs are left as Unknown. InferReferenceEffects currently demotes
//    them to reads
function CaptureNotMutate(props) {
const idx = foo(props.x);
const element = bar(props.el);
const fn = function () {
const arr = {element};
return arr[idx];
};
const aliasedElement = fn();
mutate(aliasedElement);
return aliasedElement;
}

function Component() {
const x = {};
{
const x = [];
const fn = function () {
mutate(x);
};
fn();
}
return x; // should return {}
}

function f(a) {
let x;
(() => {
x = {a};
})();
return <div x={x} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function f(a) {
let x;
(() => {
x = {};
})();
// this is not reactive on `x` as `x` is never reactive
return <div x={x} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// writing to primitives is not a 'mutate' or 'store' to context references,
// under current analysis in AnalyzeFunctions.
// <unknown> $23:TFunction = Function @deps[<unknown>
//   $21:TPrimitive,<unknown> $22:TPrimitive]:
function Component() {
let x = 40;
const fn = function () {
x = x + 1;
};
fn();
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component() {
const x = {};
{
let x = 56;
const fn = function () {
x = 42;
};
fn();
}
return x; // should return {}
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

// @logger
import {createContext, use, useState} from 'react';
import {
Stringify,
identity,
makeObject_Primitives,
useHook,
} from 'shared-runtime';
function Component() {
const w = use(Context);
// The scopes for x and x2 are interleaved, so this is one scope with two values
const x = makeObject_Primitives();
const x2 = makeObject_Primitives();
useState(null);
identity(x);
identity(x2);
// We create a scope for all call expressions, but prune those with hook calls
// in this case it's _just_ a hook call, so we don't count this as pruned
const y = useHook();
const z = [];
for (let i = 0; i < 10; i++) {
// The scope for obj is pruned bc it's in a loop
const obj = makeObject_Primitives();
z.push(obj);
}
// Overall we expect two pruned scopes (for x+x2, and obj), with 3 pruned scope values.
return <Stringify items={[w, x, x2, y, z]} />;
}
const Context = createContext();
function Wrapper() {
return (
<Context value={42}>
<Component />
</Context>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Wrapper,
params: [{}],
};

function component(props) {
// The mutable range for a extens the entire body.
// commenting out the last line of InferMutableRanges fixes it.
// my guess of what's going on is that a is aliased into the return value object literal,
// and that alias makes it look like the range of a needs to be extended to that point.
// but what's weird is that the end of a's range doesn't quite extend to the object.
let a = props.a || (props.b && props.c && props.d);
let b = (props.a && props.b && props.c) || props.d;
return {a, b};
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function component(props) {
let a = props.a || (props.b && props.c && props.d);
let b = (props.a && props.b && props.c) || props.d;
return a ? b : props.c;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

//@flow
const foo = undefined;
component C(...{scope = foo ?? null}: any) {
return scope;
}
export const FIXTURE_ENTRYPOINT = {
fn: C,
params: [{scope: undefined}],
};

function useFoo() {
while (1) {
let foo;
}
}

// @lowerContextAccess
function App() {
const {foo} = useContext(MyContext);
const {bar} = useContext(MyContext);
return <Bar foo={foo} bar={bar} />;
}

// @lowerContextAccess
function App() {
const {foo, bar} = useContext(MyContext);
return <Bar foo={foo} bar={bar} />;
}

const {mutate} = require('shared-runtime');
function Component(props) {
const object = {};
// We optimistically assume function calls within callbacks don't mutate (unless the function
// is known to be called during render), so this should get memoized
const onClick = () => {
mutate(object);
};
return <Foo callback={onClick}>{props.children}</Foo>;
}
function Foo({children}) {
return children;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{children: <div>Hello</div>}],
};

const {getNumber, identity} = require('shared-runtime');
function Component(props) {
// Two scopes: one for `getNumber()`, one for the object literal.
// Neither has dependencies so they should merge
return {a: getNumber(), b: identity(props.id), c: ['static']};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{id: 42}],
};

//@flow
component Foo() {
let x = {a: 1};
x.a++;
x.a--;
console.log(++x.a);
console.log(x.a++);
console.log(x.a);
let y = x.a++;
console.log(y);
console.log(x.a);
console.log((++x.a).toString(), (x.a++).toString(), x.a);
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [],
};

// @enableMemoizationComments
import {addOne, getNumber, identity} from 'shared-runtime';
function Component(props) {
const x = identity(props.a);
const y = addOne(x);
const z = identity(props.b);
return [x, y, z];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 1, b: 10}],
};

function Foo(props) {
let x;
true ? (x = []) : (x = {});
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function Foo(props) {
let x;
true && (x = []);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function Foo(props) {
let x;
true && ((x = []), null);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function Foo(props) {
let x;
(x = []), null;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

const {getNumber} = require('shared-runtime');
function Component(props) {
let x;
// Two scopes: one for `getNumber()`, one for the object literal.
// Neither has dependencies so they should merge
if (props.cond) {
x = {session_id: getNumber()};
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

import {useState} from 'react';
function Component() {
const [count, setCount] = useState(0);
return (
<div>
<button onClick={() => setCount(count - 1)}>Decrement</button>
{/**
* The scope for the <button> depends on just the scope for the callback,
* but the previous scope (after merging) will declare both the above
* <button> and the callback.
*/}
<button onClick={() => setCount(count + 1)}>Increment</button>
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

const {getNumber} = require('shared-runtime');
function Component(props) {
// Two scopes: one for `getNumber()`, one for the object literal.
// Neither has dependencies so they should merge
return {session_id: getNumber()};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

import {useState} from 'react';
import {Stringify} from 'shared-runtime';
// This is a translation of the original merge-consecutive-scopes which uses plain objects
// to describe the UI instead of JSX. The JSXText elements in that fixture happen to
// prevent scome scopes from merging, which concealed a bug with the merging logic.
// By avoiding JSX we eliminate extraneous instructions and more accurately test the merging.
function Component(props) {
let [state, setState] = useState(0);
return [
{component: Stringify, props: {text: 'Counter'}},
{component: 'span', props: {children: [state]}},
{
component: 'button',
props: {
'data-testid': 'button',
onClick: () => setState(state + 1),
children: ['increment'],
},
},
];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @enableInstructionReordering
import {useState} from 'react';
import {Stringify} from 'shared-runtime';
function Component() {
let [state, setState] = useState(0);
return (
<div>
<Stringify text="Counter" />
<span>{state}</span>
<button data-testid="button" onClick={() => setState(state + 1)}>
increment
</button>
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {useState} from 'react';
import {Stringify} from 'shared-runtime';
function Component() {
let [state, setState] = useState(0);
return (
<div>
<Stringify text="Counter" />
<span>{state}</span>
<button data-testid="button" onClick={() => setState(state + 1)}>
increment
</button>
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {setProperty} from 'shared-runtime';
function Component(props) {
// start of scope for y, depend on props.a
let y = {};
// nested scope for x, dependent on props.a
const x = {};
setProperty(x, props.a);
// end of scope for x
y.a = props.a;
y.x = x;
// end of scope for y
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 42}],
};

// @enableInstructionReordering
import {useState} from 'react';
function Component() {
const [state, setState] = useState(0);
const onClick = () => {
setState(s => s + 1);
};
return (
<>
<span>Count: {state}</span>
<button onClick={onClick}>Increment</button>
</>
);
}

// @validateMemoizedEffectDependencies
import {useEffect} from 'react';
function Component(props) {
const y = [[props.value]]; // merged w scope for inner array
useEffect(() => {
console.log(y);
}, [y]); // should still be a valid dependency here
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
isComponent: false,
};

function foo(a, b, c) {
// Construct and freeze x, y
const x = makeObject(a);
const y = makeObject(a);
<div>
{x}
{y}
</div>;
// z should depend on `x`, `y.method`, and `b`
const z = x[y.method](b);
return z;
}

function foo(a, b, c) {
// Construct and freeze x
const x = makeObject(a);
<div>{x}</div>;
// y should depend on `x` and `b`
const method = x.method;
const y = method.call(x, b);
return y;
}

import {addOne, shallowCopy} from 'shared-runtime';
function foo(a, b, c) {
// Construct and freeze x
const x = shallowCopy(a);
<div>{x}</div>;
// y should depend on `x` and `b`
const y = x.foo(b);
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [{foo: addOne}, 3],
isComponent: false,
};

import React from 'react';
import {useState} from 'react';
const CONST = true;
let NON_REASSIGNED_LET = true;
let REASSIGNED_LET = false;
REASSIGNED_LET = true;
function reassignedFunction() {}
reassignedFunction = true;
function nonReassignedFunction() {}
class ReassignedClass {}
ReassignedClass = true;
class NonReassignedClass {}
function Component() {
const [state] = useState(null);
return [
React,
state,
CONST,
NON_REASSIGNED_LET,
REASSIGNED_LET,
reassignedFunction,
nonReassignedFunction,
ReassignedClass,
NonReassignedClass,
];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export default Renderer = props => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
export const Renderer = props => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);

// @gating
const ErrorView = (error, _retry) => <MessageBox error={error}></MessageBox>;
const Renderer = props => (
<Foo>
<Bar></Bar>
<ErrorView></ErrorView>
</Foo>
);
export default Renderer;

function Component() {
'use foo';
'use bar';
return <div>"foo"</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: true,
};

import {useState} from 'react';
function Component(props) {
const [_state, setState] = useState();
const a = () => {
return b();
};
const b = () => {
return (
<>
<div onClick={() => onClick(true)}>a</div>
<div onClick={() => onClick(false)}>b</div>
</>
);
};
const onClick = value => {
setState(value);
};
return <div>{a()}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

// @panicThreshold(none)
import {useHook} from 'shared-runtime';
function InvalidComponent(props) {
if (props.cond) {
useHook();
}
return <div>Hello World!</div>;
}
function ValidComponent(props) {
return <div>{props.greeting}</div>;
}

function mutate(x, y) {
'use no forget';
if (x != null) {
x.value = (x.value ?? 0) + 1;
}
if (y != null) {
y.value = (y.value ?? 0) + 1;
}
}
function cond(x) {
'use no forget';
return x.value > 5;
}
function testFunction(props) {
let a = {};
let b = {};
let c = {};
let d = {};
while (true) {
let z = a;
a = b;
b = c;
c = d;
d = z;
mutate(a, b);
if (cond(a)) {
break;
}
}
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `d`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
mutate(d, null);
return {a, b, c, d};
}
export const FIXTURE_ENTRYPOINT = {
fn: testFunction,
params: [{}],
isComponent: false,
};

function mutate(x, y) {
'use no forget';
if (!Array.isArray(x.value)) {
x.value = [];
}
x.value.push(y);
if (y != null) {
y.value = x;
}
}
function Component(props) {
const a = {};
const b = [a]; // array elements alias
const c = {};
const d = {c}; // object values alias
// capture all the values into this object
const x = {};
x.b = b;
const y = mutate(x, d); // mutation aliases the arg and return value
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `x`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
if (y) {
}
// could in theory mutate any of a/b/c/x/z, so the above should be inferred as mutable
mutate(x, null);
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
isComponent: false,
};

function mutate() {}
function cond() {}
function Component(props) {
let a = {};
let b = {};
let c = {};
let d = {};
while (true) {
mutate(a, b);
if (cond(a)) {
break;
}
}
// all of these tests are seemingly readonly, since the values are never directly
// mutated again. but they are all aliased by `d`, which is later modified, and
// these are therefore mutable references:
if (a) {
}
if (b) {
}
if (c) {
}
if (d) {
}
mutate(d, null);
}

function component(a) {
let y = function () {
m(x);
};
let x = {a};
m(x);
return y;
}
function m(x) {}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: [{name: 'Jason'}],
};

import {identity, mutate, mutateAndReturnNewValue} from 'shared-runtime';
function Component(props) {
const key = {};
// Key is modified by the function, but key itself is not frozen
const element = <div key={mutateAndReturnNewValue(key)}>{props.value}</div>;
// Key is later mutated here: this mutation must be grouped with the
// jsx construction above
mutate(key);
return element;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

function Component(props) {
const [x, setX] = useState(null);
const onChange = e => {
let x = null; // intentionally shadow the original x
setX(currentX => currentX + x); // intentionally refer to shadowed x
};
return <input value={x} onChange={onChange} />;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// We should codegen nested optional properties correctly
// (i.e. placing `?` in the correct PropertyLoad)
function Component(props) {
let x = foo(props.a?.b.c.d);
return x;
}

function component(props) {
let x = [];
let y = [];
y.push(useHook(props.foo));
x.push(y);
return x;
}

function Component(props) {
const x = new Foo(...props.foo, null, ...[props.bar]);
return x;
}

// @enableFlowSuppressions
function useX() {}
function Foo(props) {
// $FlowFixMe[incompatible-type]
useX();
return null;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function Component(props) {
const filtered = props.items.filter(item => item != null);
return filtered;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [
{
items: [{a: true}, null, true, false, null, 'string', 3.14, null, [null]],
},
],
};

// Note that `a?.b.c` is semantically different from `(a?.b).c`
// Here, 'props?.a` is an optional chain, and `.b` is an unconditional load
// (nullthrows if a is nullish)
function Component(props) {
let x = (props?.a).b;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @flow
function Component() {
return (
<div
className={stylex(
// this value is a) in its own scope, b) non-reactive, and c) non-escaping
// its scope gets pruned bc it's non-escaping, but this doesn't mean we need to
// create a temporary for it
flags.feature('feature-name') ? styles.featureNameStyle : null
)}></div>
);
}

function foo(a, b, c, d) {
let x = {};
if (someVal) {
x = {b};
} else {
x = {c};
}
return x;
}

function foo(a, b, c, d) {
let x = {};
if (someVal) {
x = {b};
} else {
x = {c};
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
const y = someObj();
const z = y;
x = z;
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
x = someObj();
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c, d) {
let x = someObj();
if (a) {
let z;
if (b) {
const w = someObj();
z = w;
} else {
z = someObj();
}
const y = z;
x = z;
} else {
x = someObj();
}
x.f = 1;
return x;
}

function foo(a, b, c) {
const x = {...a};
x[b] = c[b];
x[1 + 2] = c[b * 4];
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {identity} from 'shared-runtime';
function Component(props) {
const key = 42;
const context = {
[key]: identity([props.value]),
};
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'hello!'}],
};

import {identity} from 'shared-runtime';
function Component(props) {
const key = 'KeyName';
const context = {
[key]: identity([props.value]),
};
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {identity} from 'shared-runtime';
const SCALE = 2;
function Component(props) {
const key = SCALE;
const context = {
[key]: identity([props.value]),
};
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{key: 'Sathya', value: 'Compiler'}],
};

import {identity, mutate} from 'shared-runtime';
function Component(props) {
const key = {};
const context = {
[key]: identity([props.value]),
};
mutate(key);
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

import {identity} from 'shared-runtime';
const SCALE = 2;
function Component(props) {
const {key} = props;
const context = {
[key]: identity([props.value, SCALE]),
};
return context;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{key: 'Sathya', value: 'Compiler'}],
};

function Component(props) {
const x = {['foo']: props.foo};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {
createHookWrapper,
identity,
CONST_STRING0,
CONST_STRING1,
} from 'shared-runtime';
function useHook({value}) {
return {
getValue() {
return identity(value);
},
}.getValue()
? CONST_STRING0
: CONST_STRING1;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

import {identity, createHookWrapper} from 'shared-runtime';
function useHook({isCond, value}) {
return isCond
? identity({
getValue() {
return value;
},
})
: 42;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{isCond: true, value: 0}],
};

import {createHookWrapper} from 'shared-runtime';
function useHook({isCond, value}) {
return isCond
? {
getValue() {
return value;
},
}
: 42;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{isCond: true, value: 0}],
};

import {createHookWrapper, CONST_STRING0, CONST_STRING1} from 'shared-runtime';
function useHook({value}) {
return {
getValue() {
return identity(value);
},
}
? CONST_STRING0
: CONST_STRING1;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

function Component(props) {
const x = {...props.foo};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

import {createHookWrapper, setProperty} from 'shared-runtime';
function useHook(props) {
const x = {
getX() {
return props;
},
};
const y = {
getY() {
return 'y';
},
};
return setProperty(x, y);
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

import {createHookWrapper, mutate} from 'shared-runtime';
function useHook(a) {
const x = {a};
let obj = {
method() {
mutate(x);
return x;
},
};
return obj.method();
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{x: 1}],
};

import {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
const x = mutateAndReturn({value});
const obj = {
getValue() {
return value;
},
};
mutate(x);
return obj;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

import {createHookWrapper, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
const x = mutateAndReturn({value});
const obj = {
getValue() {
return x;
},
};
return obj;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

import {createHookWrapper} from 'shared-runtime';
import {useState} from 'react';
function useFoo() {
const [state, _setState] = useState(false);
return {
func() {
return state;
},
};
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useFoo),
params: [{}],
};

import {createHookWrapper, mutate, mutateAndReturn} from 'shared-runtime';
function useHook({value}) {
const x = mutateAndReturn({value});
const obj = {
getValue() {
return x;
},
};
mutate(obj);
return obj;
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

function Component() {
let obj = {
method() {
return 1;
},
};
return obj.method();
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{x: 1}, {a: 2}, {b: 2}],
};

import {makeObject_Primitives} from 'shared-runtime';
function Component(props) {
const object = makeObject_Primitives();
if (props.cond) {
object.value = 1;
return object;
} else {
object.value = props.value;
return object;
}
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: false, value: [0, 1, 2]}],
};

function component({a, b}) {
let y = {a};
let z = {b};
return {y, z};
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
const x = a.x;
const y = {...b.c.d};
y.z = c.d.e;
foo(a.b.c);
[a.b.c];
}

import {createHookWrapper} from 'shared-runtime';
function useHook({a, b}) {
return {
x: function () {
return [a];
},
y() {
return [b];
},
};
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{a: 1, b: 2}],
};

import {createHookWrapper} from 'shared-runtime';
function useHook({a, b, c}) {
return {
x: [a],
y() {
return [b];
},
z: {c},
};
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{a: 1, b: 2, c: 2}],
};

import {useState} from 'react';
import {createHookWrapper} from 'shared-runtime';
function useHook({value}) {
const [state] = useState(false);
return {
getX() {
return {
a: [],
getY() {
return value;
},
state,
};
},
};
}
export const FIXTURE_ENTRYPOINT = {
fn: createHookWrapper(useHook),
params: [{value: 0}],
};

// @enableChangeVariableCodegen
function Component(props) {
const c_0 = [props.a, props.b.c];
return c_0;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{a: 3.14, b: {c: true}}],
};

function Component(props) {
return call?.(props.a)?.(props.b)?.(props.c);
}

import {useFragment} from 'shared-runtime';
function Component(props) {
const item = useFragment(
graphql`
fragment F on T {
id
}
`,
props.item
);
return item.items?.map(item => renderItem(item)) ?? [];
}

function Component(props) {
return foo?.(props);
}

function Component(props) {
const x = makeOptionalFunction(props);
// for a regular call, the JSX element could be independently memoized
// since it is an immutable value. however, because the call is optional,
// we can't extract out independent memoization for the element w/o
// forcing that argument to evaluate unconditionally
const y = x?.(
<div>
<span>{props.text}</span>
</div>
);
return y;
}

function Component(props) {
return props?.items?.map?.(render)?.filter(Boolean) ?? [];
}

function Component(props) {
const x = makeOptionalFunction(props);
const y = makeObject(props);
const z = x?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
let x = a?.b.c[0];
return x;
}

function Component(props) {
const object = makeObject(props);
return object?.[props.key];
}

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
function Component(props) {
const data = useMemo(() => {
return props?.items.edges?.nodes.map();
}, [props?.items.edges?.nodes]);
return <Foo data={data} />;
}

function Component(props) {
const x = makeObject();
return x?.[foo(props.value)];
}

// Note that `a?.b.c` is semantically different from `(a?.b).c`
// We should codegen the correct member expressions
function Component(props) {
let x = props?.b.c;
let y = props?.b.c.d?.e.f.g?.h;
return {x, y};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const data = useMemo(() => {
const x = [];
x.push(props?.a.b?.c.d?.e);
x.push(props.a?.b.c?.d.e);
return x;
}, [props.a.b.c.d.e]);
return <ValidateMemoization inputs={[props.a.b.c.d.e]} output={x} />;
}

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const data = useMemo(() => {
const x = [];
x.push(props?.items);
x.push(props.items);
return x;
}, [props.items]);
return <ValidateMemoization inputs={[props.items]} output={data} />;
}

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const data = useMemo(() => {
const x = [];
x.push(props?.items);
return x;
}, [props?.items]);
return <ValidateMemoization inputs={[props?.items]} output={data} />;
}

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const data = useMemo(() => {
const x = [];
x.push(props?.items);
if (props.cond) {
x.push(props?.items);
}
return x;
}, [props?.items, props.cond]);
return (
<ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
);
}

// @validatePreserveExistingMemoizationGuarantees @enableOptionalDependencies
import {ValidateMemoization} from 'shared-runtime';
function Component(props) {
const data = useMemo(() => {
const x = [];
x.push(props?.items);
if (props.cond) {
x.push(props.items);
}
return x;
}, [props?.items, props.cond]);
return (
<ValidateMemoization inputs={[props?.items, props.cond]} output={data} />
);
}

function Component(props) {
const x = makeObject();
return x.y?.[props.a?.[props.b?.[props.c]]];
}

function Foo(props) {
let x = bar(props.a);
let y = x?.b;
let z = useBar(y);
return z;
}

function Component(props) {
const x = makeObject(props);
const y = makeObject(props);
const z = x.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
const x = makeOptionalObject(props);
const y = makeObject(props);
const z = x?.method(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

function Component(props) {
const x = makeOptionalObject(props);
const y = makeObject(props);
const z = x?.optionalMethod?.(y.a, props.a, foo(y.b), bar(props.b));
return z;
}

import {Stringify} from 'shared-runtime';
function Component(props) {
// test outlined functions with destructured parameters - the
// temporary for the destructured param must be promoted
return (
<>
{props.items.map(({id, name}) => (
<Stringify key={id} name={name} />
))}
</>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: [{id: 1, name: 'one'}]}],
};

import {Stringify} from 'shared-runtime';
function Component(props) {
return (
<div>
{props.items.map(item => (
<Stringify key={item.id} item={item.name} />
))}
</div>
);
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{items: [{id: 1, name: 'one'}]}],
};

const Component2 = props => {
return (
<ul>
{props.items.map(item => (
<li key={item.id}>{item.name}</li>
))}
</ul>
);
};
export const FIXTURE_ENTRYPOINT = {
fn: Component2,
params: [
{
items: [
{id: 2, name: 'foo'},
{id: 3, name: 'bar'},
],
},
],
};

function Component(props) {
return <View {...props} />;
}
const View = React.memo(({items}) => {
return (
<ul>
{items.map(item => (
<li key={item.id}>{item.name}</li>
))}
</ul>
);
});
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [
{
items: [
{id: 2, name: 'foo'},
{id: 3, name: 'bar'},
],
},
],
};

function foo(a, b, c) {
const x = [];
const y = [];
if (x) {
}
y.push(a);
x.push(b);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b) {
let x = [];
let y = [];
x.push(a);
y.push(b);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b) {
let x = [];
let y = [];
y.push(b);
x.push(a);
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
let x = [];
if (a) {
let y = [];
if (b) {
y.push(c);
}
x.push(<div>{y}</div>);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
let x = [];
let y = [];
while (c) {
y.push(b);
x.push(a);
}
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function foo(a, b, c) {
let x = [];
if (a) {
let y = [];
if (b) {
y.push(c);
}
x.push(y);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
let x = [];
let y = null;
if (props.cond) {
x.push(props.a);
// oops no memo!
return x;
} else {
y = foo();
if (props.b) {
return;
}
}
return y;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true, a: 42}],
};

import {makeArray} from 'shared-runtime';
function Component(props) {
const x = {};
let y;
if (props.cond) {
if (props.cond2) {
y = [props.value];
} else {
y = [props.value2];
}
} else {
y = [];
}
// This should be inferred as `<store> y` s.t. `x` can still
// be independently memoized. *But* this also must properly
// extend the mutable range of the array literals in the
// if/else branches
y.push(x);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true, cond2: true, value: 42}],
sequentialRenders: [
{cond: true, cond2: true, value: 3.14},
{cond: true, cond2: true, value: 42},
{cond: true, cond2: true, value: 3.14},
{cond: true, cond2: false, value2: 3.14},
{cond: true, cond2: false, value2: 42},
{cond: true, cond2: false, value2: 3.14},
{cond: false},
{cond: false},
],
};

function Component(props) {
const x = {};
let y;
if (props.cond) {
y = [props.value];
} else {
y = [];
}
// This should be inferred as `<store> y` s.t. `x` can still
// be independently memoized. *But* this also must properly
// extend the mutable range of the array literals in the
// if/else branches
y.push(x);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true, value: 42}],
sequentialRenders: [
{cond: true, value: 3.14},
{cond: false, value: 3.14},
{cond: true, value: 42},
],
};

// @debug
function Component(props) {
const x = {};
let y;
if (props.cond) {
y = {};
} else {
y = {a: props.a};
}
// This should be inferred as `<store> y` s.t. `x` can still
// be independently memoized. *But* this also must properly
// extend the mutable range of the object literals in the
// if/else branches
y.x = x;
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: false, a: 'a!'}],
};

function Foo() {
return <div> {', '}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Foo,
params: [{}],
};

function component(a) {
let x = 'foo';
if (a) {
x = 'bar';
} else {
x = 'baz';
}
let y = x;
mutate(y);
return y;
}

// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
import {identity, mutate, setProperty} from 'shared-runtime';
//   y depends on either props.b or props.b + 1
function PrimitiveAsDepNested(props) {
let x = {};
mutate(x);
let y = identity(props.b + 1);
setProperty(x, props.a);
return [x, y];
}
export const FIXTURE_ENTRYPOINT = {
fn: PrimitiveAsDepNested,
params: [{a: 1, b: 2}],
sequentialRenders: [
// change b
{a: 1, b: 3},
// change b
{a: 1, b: 4},
// change a
{a: 2, b: 4},
// change a
{a: 3, b: 4},
],
};

// props.b + 1 is an non-allocating expression, which means Forget can
// emit it trivially and repeatedly (e.g. no need to memoize props.b + 1
// separately from props.b)
// Correctness:
//   y depends on either props.b or props.b + 1
function PrimitiveAsDep(props) {
let y = foo(props.b + 1);
return y;
}

// @enableForest
function Component({base, start, increment, test}) {
let value = base;
for (let i = start; i < test; i += increment) {
value += i;
}
return <div>{value}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{base: 0, start: 0, test: 10, increment: 1}],
sequentialRenders: [
{base: 0, start: 1, test: 10, increment: 1},
{base: 0, start: 0, test: 10, increment: 2},
{base: 2, start: 0, test: 10, increment: 2},
{base: 0, start: 0, test: 11, increment: 2},
],
};

function component(a, b) {
let z = {a, b};
let x = function () {
console.log(z);
};
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const x = {};
const y = [];
x.y = y;
const child = <Component data={y} />;
x.y.push(props.p0);
return <Component data={x}>{child}</Component>;
}

// Should print A, arg, original
function Component() {
const changeF = o => {
o.f = () => console.log('new');
};
const x = {
f: () => console.log('original'),
};
(console.log('A'), x).f((changeF(x), console.log('arg'), 1));
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
isComponent: false,
};

function Component(props) {
const x = foo.bar(...props.a, null, ...props.b);
return x;
}

import {useHook} from 'shared-runtime';
function Component(props) {
const x = [];
useHook(); // intersperse a hook call to prevent memoization of x
x.push(props.value);
const y = [x];
return [y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

import {useHook} from 'shared-runtime';
function Component(props) {
const o = {};
const x = <div>{props.value}</div>; // create within the range of x to group with x
useHook(); // intersperse a hook call to prevent memoization of x
o.value = props.value;
const y = <div>{x}</div>;
return <div>{y}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

import {useHook} from 'shared-runtime';
function Component(props) {
const x = new Foo();
useHook(); // intersperse a hook call to prevent memoization of x
x.value = props.value;
const y = {x};
return {y};
}
class Foo {}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

import {useHook} from 'shared-runtime';
function Component(props) {
const x = {};
useHook(); // intersperse a hook call to prevent memoization of x
x.value = props.value;
const y = {x};
return {y};
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

import {useHook, identity} from 'shared-runtime';
function Component(props) {
let x = 42;
if (props.cond) {
x = [];
}
useHook(); // intersperse a hook call to prevent memoization of x
identity(x);
const y = [x];
return [y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 'sathya'}],
};

export function Component() {
return <Child text='Some \"text\"' />;
}
function Child(props) {
return props.text;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

export function Component() {
return <Child text='Some "text"' />;
}
function Child(props) {
return props.text;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

export function Component() {
// Test what happens if a string with double-quotes is interpolated via constant propagation
const text = 'Some "text"';
return <Child text={text} />;
}
function Child(props) {
return props.text;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{}],
};

const FooContext = React.createContext({current: null});
function Component(props) {
const foo = React.useContext(FooContext);
const ref = React.useRef();
const [x, setX] = React.useState(false);
const onClick = () => {
setX(true);
ref.current = true;
};
return <div onClick={onClick}>{React.cloneElement(props.children)}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{children: <div>Hello</div>}],
};

function Component(props) {
let x = 0;
let y = 0;
let z = 0;
do {
x += 1;
y += 1;
z = y;
} while (x < props.limit);
return [z];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{limit: 10},
{limit: 10},
{limit: 1},
{limit: 1},
{limit: 10},
{limit: 1},
{limit: 10},
{limit: 1},
],
};

function Component(props) {
let x;
let i = 0;
do {
if (i > 10) {
x = 10;
} else {
x = 1;
}
i++;
} while (i < props.test);
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose value is affected by
// `props.test` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{test: 12},
{test: 12},
{test: 1},
{test: 1},
{test: 12},
{test: 1},
{test: 12},
{test: 1},
],
};

function Component(props) {
let x;
for (let i = props.init; i < 10; i++) {
if (i === 0) {
x = 0;
break;
} else {
x = 1;
break;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose initial value `props.init` is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{init: 0},
{init: 0},
{init: 10},
{init: 10},
{init: 0},
{init: 10},
{init: 0},
{init: 10},
],
};

function Component(props) {
let x;
for (let i = 0; i < props.test; i++) {
if (i > 10) {
x = 10;
} else {
x = 1;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose value is capped by
// `props.test` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{test: 12},
{test: 12},
{test: 1},
{test: 1},
{test: 12},
{test: 1},
{test: 12},
{test: 1},
],
};

function Component(props) {
let x;
for (let i = 0; i < 10; i += props.update) {
if (i > 0 && i % 2 === 0) {
x = 2;
} else {
x = 1;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose possible values are
// affected by `props.update` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{update: 2},
{update: 2},
{update: 1},
{update: 1},
{update: 2},
{update: 1},
{update: 2},
{update: 1},
],
};

function Component(props) {
let x;
for (const key in props.values) {
const i = parseInt(key, 10);
if (i > 10) {
x = 10;
} else {
x = 1;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose value is derived from
// `props.values` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{values: {'12': true}},
{values: {'12': true}},
{values: {'1': true}},
{values: {'1': true}},
{values: {'12': true}},
{values: {'1': true}},
{values: {'12': true}},
{values: {'1': true}},
],
};

function Component(props) {
let x;
for (const i of props.values) {
if (i > 10) {
x = 10;
} else {
x = 1;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose value is derived from
// `props.values` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{values: [12]},
{values: [12]},
{values: [1]},
{values: [1]},
{values: [12]},
{values: [1]},
{values: [12]},
{values: [1]},
],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(false);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x = 0;
do {
x += 1;
} while (c[0][0]);
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push({a: false});
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
for (const i in c[0][0]) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(0);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
for (let i = c[0][0]; i < 10; i++) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(null);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
for (const i of c[0]) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(10);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
for (let i = 0; i < c[0][0]; i++) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(10);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
for (let i = 0; i < 10; i += c[0][0]) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(null);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
if (c[0][0]) {
x = 1;
} else {
x = 2;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(null);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
switch (c[0][0]) {
case true: {
x = 1;
break;
}
default: {
x = 2;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
// a and b are independent but their mutations are interleaved, so
// they get grouped in a reactive scope. this means that a becomes
// reactive since it will effectively re-evaluate based on a reactive
// input
const a = [];
const b = [];
b.push(props.cond);
a.push(null);
// Downstream consumer of a, which initially seems non-reactive except
// that a becomes reactive, per above
const c = [a];
let x;
while (c[0][0]) {
x = 1;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `c[0]` which becomes reactive via
// being interleaved with `b`.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{cond: true}],
};

function Component(props) {
let x;
if (props.cond) {
x = 1;
} else {
x = 2;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `props.cond` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

import {identity} from 'shared-runtime';
function Component(props) {
let x;
// Reassign `x` based on a reactive value, but inside a function expression
// to make it a context variable
const f = () => {
if (props.cond) {
x = 1;
} else {
x = 2;
}
};
// Pass `f` through a function to prevent IIFE inlining optimizations
const f2 = identity(f);
f2();
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `props.cond` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

import invariant from 'invariant';
import {useState} from 'react';
function Component(props) {
const [x, setX] = useState(false);
const [y, setY] = useState(false);
let setState;
if (props.cond) {
setState = setX;
} else {
setState = setY;
}
const setState2 = setState;
const stateObject = {setState: setState2};
return (
<Foo
cond={props.cond}
setX={setX}
setY={setY}
setState={stateObject.setState}
/>
);
}
function Foo({cond, setX, setY, setState}) {
if (cond) {
invariant(setState === setX, 'Expected the correct setState function');
} else {
invariant(setState === setY, 'Expected the correct setState function');
}
return 'ok';
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

function Component(props) {
let x = 0;
let value = null;
loop: for (let i = 0; i < 10; i++) {
switch (value) {
case true: {
x = 1;
break loop;
}
case false: {
x = 2;
break loop;
}
}
value = props.cond;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `value` used as the switch test
// condition. That variable is initially null on the first iteration
// of the loop, but is later set to `props.value` which is reactive.
// Therefore x should be treated as reactive.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

function Component(props) {
let x;
switch (props.cond) {
case true: {
x = 1;
break;
}
case false: {
x = 2;
break;
}
default: {
x = 3;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `props.cond` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

const GLOBAL = 42;
function Component({value}) {
let x;
switch (GLOBAL) {
case value: {
x = 1;
break;
}
default: {
x = 2;
}
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" value `props.value` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{value: GLOBAL},
{value: GLOBAL},
{value: null},
{value: null},
{value: GLOBAL},
{value: null},
{value: GLOBAL},
{value: null},
],
};

function Component(props) {
// x is mutated conditionally based on a reactive value,
// so it needs to be considered reactive
let x = [];
if (props.cond) {
x.push(1);
}
// Since x is reactive, y is now reactively controlled too:
let y = false;
if (x[0]) {
y = true;
}
// Thus this value should be reactive on `y`:
return [y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

function Component(props) {
// x is mutated conditionally based on a reactive value,
// so it needs to be considered reactive
let x = [];
if (props.cond) {
x.push(1);
}
// Since x is reactive, y is now reactively controlled too:
let y = false;
switch (x[0]) {
case 1: {
y = true;
break;
}
}
// Thus this value should be reactive on `y`:
return [y];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{cond: true},
{cond: true},
{cond: false},
{cond: false},
{cond: true},
{cond: false},
{cond: true},
{cond: false},
],
};

function Component(props) {
let x;
let i = 0;
while (i < props.test) {
if (i > 10) {
x = 10;
} else {
x = 1;
}
i++;
}
// The values assigned to `x` are non-reactive, but the value of `x`
// depends on the "control" variable `i`, whose value is affected by
// `props.test` which is reactive.
// Therefore x should be treated as reactive too.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [],
sequentialRenders: [
{test: 12},
{test: 12},
{test: 1},
{test: 1},
{test: 12},
{test: 1},
{test: 12},
{test: 1},
],
};

function Component(props) {
return props.post.feedback.comments?.edges?.map(render);
}

function Component(props) {
let x = 0;
let y = 0;
while (x === 0) {
x = y;
y = props.value;
}
// x and y initially start out with non-reactive values,
// but after an iteration of the loop y becomes reactive,
// and this reactive value then flows into x on the next
// loop iteration, making x reactive.
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{value: 42}],
};

function Component(props) {
const x = {};
const y = props.y;
return [x, y]; // x is captured here along with a reactive value. this shouldn't make `x` reactive!
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{y: 42}],
};

const {mutate} = require('shared-runtime');
function Component(props) {
const x = {};
const y = props.y;
const z = [x, y];
mutate(z);
// x's object identity can change bc it co-mutates with z, which is reactive via props.y
return [x];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: [{y: 42}],
};

function foo() {
let x = {};
let y = [];
let z = {};
y.push(z);
x.y = y;
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: [],
isComponent: false,
};

function foo(a, b, c) {
const x = [];
if (a) {
const y = [];
y.push(b);
x.push(<div>{y}</div>);
} else {
x.push(c);
}
return x;
}
export const FIXTURE_ENTRYPOINT = {
fn: foo,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function f(a, b) {
let x = []; // <- x starts being mutable here.
if (a.length === 1) {
if (b) {
x.push(b); // <- x stops being mutable here.
}
}
return <div>{x}</div>;
}
export const FIXTURE_ENTRYPOINT = {
fn: f,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
// a and b are technically independent, but their mutation is interleaved
// so they are grouped in a single reactive scope. a does not have any
// reactive inputs, but b does. therefore, we have to treat a as reactive,
// since it will be recreated based on a reactive input.
const a = {};
const b = [];
b.push(props.b);
a.a = null;
// because a may recreate when b does, it becomes reactive. we have to recreate
// c if a changes.
const c = [a];
// Example usage that could fail if we didn't treat a as reactive:
//  const [c, a] = Component({b: ...});
//  assert(c[0] === a);
return [c, a];
}
export const FIXTURE_ENTRYPOINT = {
fn: Component,
params: ['TodoAdd'],
isComponent: 'TodoAdd',
};

function Component(props) {
const items = bar();
mutate(items[props.key], props.a);
const count = foo(items.length + 1);
return {items, count};
}
